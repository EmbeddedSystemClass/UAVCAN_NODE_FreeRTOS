ARM GAS  /tmp/ccUNHGxP.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"uavcan.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.shouldAcceptTransfer,"ax",%progbits
  16              		.align	1
  17              		.global	shouldAcceptTransfer
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	shouldAcceptTransfer:
  24              	.LFB65:
  25              		.file 1 "Src/uavcan.c"
   1:Src/uavcan.c  **** #include <stdio.h>
   2:Src/uavcan.c  **** #include <stdlib.h>
   3:Src/uavcan.c  **** #include "canard.h"
   4:Src/uavcan.c  **** #include "canard_stm32.h"
   5:Src/uavcan.c  **** #include "uavcan.h"
   6:Src/uavcan.c  **** #include "stm32f1xx_hal.h"
   7:Src/uavcan.c  **** #include "main.h"
   8:Src/uavcan.c  **** 
   9:Src/uavcan.c  **** #define CANARD_SPIN_PERIOD   500
  10:Src/uavcan.c  **** #define PUBLISHER_PERIOD_mS     25
  11:Src/uavcan.c  ****             
  12:Src/uavcan.c  **** static CanardInstance g_canard;                //The library instance
  13:Src/uavcan.c  **** static uint8_t g_canard_memory_pool[1024];     //Arena for memory allocation, used by the library
  14:Src/uavcan.c  **** static uint32_t  g_uptime = 0;
  15:Src/uavcan.c  **** uint16_t rc_pwm[6] = {0,0,0,0,0,0};
  16:Src/uavcan.c  **** 
  17:Src/uavcan.c  **** 
  18:Src/uavcan.c  **** 
  19:Src/uavcan.c  ****  
  20:Src/uavcan.c  **** 
  21:Src/uavcan.c  **** //////////////////////////////////////////////////////////////////////////////////////
  22:Src/uavcan.c  **** 
  23:Src/uavcan.c  **** bool shouldAcceptTransfer(const CanardInstance* ins,
  24:Src/uavcan.c  ****                           uint64_t* out_data_type_signature,
  25:Src/uavcan.c  ****                           uint16_t data_type_id,
  26:Src/uavcan.c  ****                           CanardTransferType transfer_type,
  27:Src/uavcan.c  ****                           uint8_t source_node_id)
  28:Src/uavcan.c  **** {
  26              		.loc 1 28 0
  27              		.cfi_startproc
  28              		@ args = 4, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
ARM GAS  /tmp/ccUNHGxP.s 			page 2


  31              	.LVL0:
  29:Src/uavcan.c  ****     if ((transfer_type == CanardTransferTypeRequest) &&(data_type_id == UAVCAN_GET_NODE_INFO_DATA_T
  32              		.loc 1 29 0
  33 0000 012B     		cmp	r3, #1
  34 0002 07D0     		beq	.L6
  35              	.L2:
  30:Src/uavcan.c  ****     {
  31:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE;
  32:Src/uavcan.c  ****         return true;
  33:Src/uavcan.c  ****     }
  34:Src/uavcan.c  ****     if (data_type_id == UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_ID)
  36              		.loc 1 34 0
  37 0004 40F20643 		movw	r3, #1030
  38              	.LVL1:
  39 0008 9A42     		cmp	r2, r3
  40 000a 0CD0     		beq	.L7
  35:Src/uavcan.c  ****     {
  36:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_SIGNATURE;
  37:Src/uavcan.c  ****         return true;
  38:Src/uavcan.c  ****     }
  39:Src/uavcan.c  ****     if (data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID)
  41              		.loc 1 39 0
  42 000c 0B2A     		cmp	r2, #11
  43 000e 11D0     		beq	.L8
  40:Src/uavcan.c  ****     {
  41:Src/uavcan.c  ****         *out_data_type_signature = UAVCAN_PROTOCOL_PARAM_GETSET_SIGNATURE;
  42:Src/uavcan.c  ****         return true;
  43:Src/uavcan.c  ****     }
  44:Src/uavcan.c  ****     return false;
  44              		.loc 1 44 0
  45 0010 0020     		movs	r0, #0
  46              	.LVL2:
  45:Src/uavcan.c  **** }
  47              		.loc 1 45 0
  48 0012 7047     		bx	lr
  49              	.LVL3:
  50              	.L6:
  29:Src/uavcan.c  ****     {
  51              		.loc 1 29 0 discriminator 1
  52 0014 012A     		cmp	r2, #1
  53 0016 F5D1     		bne	.L2
  31:Src/uavcan.c  ****         return true;
  54              		.loc 1 31 0
  55 0018 0BA3     		adr	r3, .L9
  56 001a D3E90023 		ldrd	r2, [r3]
  57              	.LVL4:
  58 001e C1E90023 		strd	r2, [r1]
  32:Src/uavcan.c  ****     }
  59              		.loc 1 32 0
  60 0022 0120     		movs	r0, #1
  61              	.LVL5:
  62 0024 7047     		bx	lr
  63              	.LVL6:
  64              	.L7:
  36:Src/uavcan.c  ****         return true;
  65              		.loc 1 36 0
  66 0026 0AA3     		adr	r3, .L9+8
ARM GAS  /tmp/ccUNHGxP.s 			page 3


  67 0028 D3E90023 		ldrd	r2, [r3]
  68              	.LVL7:
  69 002c C1E90023 		strd	r2, [r1]
  37:Src/uavcan.c  ****     }
  70              		.loc 1 37 0
  71 0030 0120     		movs	r0, #1
  72              	.LVL8:
  73 0032 7047     		bx	lr
  74              	.LVL9:
  75              	.L8:
  41:Src/uavcan.c  ****         return true;
  76              		.loc 1 41 0
  77 0034 08A3     		adr	r3, .L9+16
  78 0036 D3E90023 		ldrd	r2, [r3]
  79              	.LVL10:
  80 003a C1E90023 		strd	r2, [r1]
  42:Src/uavcan.c  ****     }
  81              		.loc 1 42 0
  82 003e 0120     		movs	r0, #1
  83              	.LVL11:
  84 0040 7047     		bx	lr
  85              	.L10:
  86 0042 00BFAFF3 		.align	3
  86      0080
  87              	.L9:
  88 0048 9E6AC421 		.word	566520478
  89 004c 818A46EE 		.word	-297366911
  90 0050 1D95ECD7 		.word	-672361187
  91 0054 875C7F21 		.word	561994887
  92 0058 D5A4D139 		.word	970040533
  93 005c F922B6A7 		.word	-1481235719
  94              		.cfi_endproc
  95              	.LFE65:
  97              		.section	.text.uavcanInit,"ax",%progbits
  98              		.align	1
  99              		.global	uavcanInit
 100              		.syntax unified
 101              		.thumb
 102              		.thumb_func
 103              		.fpu softvfp
 105              	uavcanInit:
 106              	.LFB68:
  46:Src/uavcan.c  **** 
  47:Src/uavcan.c  **** //////////////////////////////////////////////////////////////////////////////////////
  48:Src/uavcan.c  **** 
  49:Src/uavcan.c  **** void onTransferReceived(CanardInstance* ins, CanardRxTransfer* transfer)
  50:Src/uavcan.c  **** {
  51:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) && (transfer->data_type_id == UAVCAN
  52:Src/uavcan.c  ****     {
  53:Src/uavcan.c  ****         getNodeInfoHandleCanard(transfer);
  54:Src/uavcan.c  ****     } 
  55:Src/uavcan.c  **** 
  56:Src/uavcan.c  ****     if (transfer->data_type_id == UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_ID)
  57:Src/uavcan.c  ****     {
  58:Src/uavcan.c  ****         rawcmdHandleCanard(transfer);
  59:Src/uavcan.c  ****     }
  60:Src/uavcan.c  **** 
ARM GAS  /tmp/ccUNHGxP.s 			page 4


  61:Src/uavcan.c  ****     if (transfer->data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID)
  62:Src/uavcan.c  ****     {
  63:Src/uavcan.c  ****         getsetHandleCanard(transfer);
  64:Src/uavcan.c  ****     }
  65:Src/uavcan.c  ****     
  66:Src/uavcan.c  **** }
  67:Src/uavcan.c  **** 
  68:Src/uavcan.c  **** void getNodeInfoHandleCanard(CanardRxTransfer* transfer)
  69:Src/uavcan.c  **** {
  70:Src/uavcan.c  ****         uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE];
  71:Src/uavcan.c  ****         memset(buffer,0,UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
  72:Src/uavcan.c  ****         uint16_t len = makeNodeInfoMessage(buffer);
  73:Src/uavcan.c  ****         int result = canardRequestOrRespond(&g_canard,
  74:Src/uavcan.c  ****                                             transfer->source_node_id,
  75:Src/uavcan.c  ****                                             UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE,
  76:Src/uavcan.c  ****                                             UAVCAN_GET_NODE_INFO_DATA_TYPE_ID,
  77:Src/uavcan.c  ****                                             &transfer->transfer_id,
  78:Src/uavcan.c  ****                                             transfer->priority,
  79:Src/uavcan.c  ****                                             CanardResponse,
  80:Src/uavcan.c  ****                                             &buffer[0],
  81:Src/uavcan.c  ****                                             (uint16_t)len);
  82:Src/uavcan.c  **** }
  83:Src/uavcan.c  **** 
  84:Src/uavcan.c  **** 
  85:Src/uavcan.c  **** 
  86:Src/uavcan.c  **** 
  87:Src/uavcan.c  **** 
  88:Src/uavcan.c  **** void uavcanInit(void)
  89:Src/uavcan.c  **** {
 107              		.loc 1 89 0
 108              		.cfi_startproc
 109              		@ args = 0, pretend = 0, frame = 8
 110              		@ frame_needed = 0, uses_anonymous_args = 0
 111 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 112              	.LCFI0:
 113              		.cfi_def_cfa_offset 20
 114              		.cfi_offset 4, -20
 115              		.cfi_offset 5, -16
 116              		.cfi_offset 6, -12
 117              		.cfi_offset 7, -8
 118              		.cfi_offset 14, -4
 119 0002 85B0     		sub	sp, sp, #20
 120              	.LCFI1:
 121              		.cfi_def_cfa_offset 40
  90:Src/uavcan.c  ****     CanardSTM32CANTimings timings;
  91:Src/uavcan.c  ****     int result = canardSTM32ComputeCANTimings(HAL_RCC_GetPCLK1Freq(), 1000000, &timings);
 122              		.loc 1 91 0
 123 0004 FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 124              	.LVL12:
 125              	.LBB11:
 126              	.LBB12:
 127              		.file 2 "libcanard/drivers/stm32/canard_stm32.h"
   1:libcanard/drivers/stm32/canard_stm32.h **** /*
   2:libcanard/drivers/stm32/canard_stm32.h ****  * Copyright (c) 2017 UAVCAN Team
   3:libcanard/drivers/stm32/canard_stm32.h ****  *
   4:libcanard/drivers/stm32/canard_stm32.h ****  * Distributed under the MIT License, available in the file LICENSE.
   5:libcanard/drivers/stm32/canard_stm32.h ****  *
ARM GAS  /tmp/ccUNHGxP.s 			page 5


   6:libcanard/drivers/stm32/canard_stm32.h ****  * Author: Pavel Kirienko <pavel.kirienko@zubax.com>
   7:libcanard/drivers/stm32/canard_stm32.h ****  */
   8:libcanard/drivers/stm32/canard_stm32.h **** 
   9:libcanard/drivers/stm32/canard_stm32.h **** #ifndef CANARD_STM32_H
  10:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_H
  11:libcanard/drivers/stm32/canard_stm32.h **** 
  12:libcanard/drivers/stm32/canard_stm32.h **** #include <canard.h>
  13:libcanard/drivers/stm32/canard_stm32.h **** #include <string.h>     // NOLINT
  14:libcanard/drivers/stm32/canard_stm32.h **** 
  15:libcanard/drivers/stm32/canard_stm32.h **** 
  16:libcanard/drivers/stm32/canard_stm32.h **** #ifdef __cplusplus
  17:libcanard/drivers/stm32/canard_stm32.h **** extern "C"
  18:libcanard/drivers/stm32/canard_stm32.h **** {
  19:libcanard/drivers/stm32/canard_stm32.h **** #endif
  20:libcanard/drivers/stm32/canard_stm32.h **** 
  21:libcanard/drivers/stm32/canard_stm32.h **** /**
  22:libcanard/drivers/stm32/canard_stm32.h ****  * Set this build config macro to 1 to use CAN2 instead of CAN1, if available.
  23:libcanard/drivers/stm32/canard_stm32.h ****  * Setting this parameter when CAN2 is not available may not be detected at compile time!
  24:libcanard/drivers/stm32/canard_stm32.h ****  */
  25:libcanard/drivers/stm32/canard_stm32.h **** #if !defined(CANARD_STM32_USE_CAN2)
  26:libcanard/drivers/stm32/canard_stm32.h **** # define CANARD_STM32_USE_CAN2                                  0
  27:libcanard/drivers/stm32/canard_stm32.h **** #endif
  28:libcanard/drivers/stm32/canard_stm32.h **** 
  29:libcanard/drivers/stm32/canard_stm32.h **** /**
  30:libcanard/drivers/stm32/canard_stm32.h ****  * Trigger an assertion failure if inner priority inversion is detected at run time.
  31:libcanard/drivers/stm32/canard_stm32.h ****  * This setting has no effect in release builds, where NDEBUG is defined.
  32:libcanard/drivers/stm32/canard_stm32.h ****  */
  33:libcanard/drivers/stm32/canard_stm32.h **** #if !defined(CANARD_STM32_DEBUG_INNER_PRIORITY_INVERSION)
  34:libcanard/drivers/stm32/canard_stm32.h **** # define CANARD_STM32_DEBUG_INNER_PRIORITY_INVERSION            1
  35:libcanard/drivers/stm32/canard_stm32.h **** #endif
  36:libcanard/drivers/stm32/canard_stm32.h **** 
  37:libcanard/drivers/stm32/canard_stm32.h **** /**
  38:libcanard/drivers/stm32/canard_stm32.h ****  * Driver error codes.
  39:libcanard/drivers/stm32/canard_stm32.h ****  * These values are returned negated from API functions that return int.
  40:libcanard/drivers/stm32/canard_stm32.h ****  */
  41:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE                         1000
  42:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_MSR_INAK_NOT_SET                             1001
  43:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_MSR_INAK_NOT_CLEARED                         1002
  44:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_ERROR_UNSUPPORTED_FRAME_FORMAT                     1003
  45:libcanard/drivers/stm32/canard_stm32.h **** 
  46:libcanard/drivers/stm32/canard_stm32.h **** /**
  47:libcanard/drivers/stm32/canard_stm32.h ****  * This is defined by the bxCAN hardware.
  48:libcanard/drivers/stm32/canard_stm32.h ****  * Devices with only one CAN interface have 14 filters (e.g. F103).
  49:libcanard/drivers/stm32/canard_stm32.h ****  * Devices with two CAN interfaces have 28 filters, which are shared between two interfaces (e.g. F
  50:libcanard/drivers/stm32/canard_stm32.h ****  * The filters are distributed between CAN1 and CAN2 by means of the CAN2 start filter bank selecti
  51:libcanard/drivers/stm32/canard_stm32.h ****  * which is a number from 1 to 27 inclusive. Seeing as the start bank cannot be set to 0, CAN2 has 
  52:libcanard/drivers/stm32/canard_stm32.h ****  * to use.
  53:libcanard/drivers/stm32/canard_stm32.h ****  */
  54:libcanard/drivers/stm32/canard_stm32.h **** #define CANARD_STM32_NUM_ACCEPTANCE_FILTERS                            14U
  55:libcanard/drivers/stm32/canard_stm32.h **** 
  56:libcanard/drivers/stm32/canard_stm32.h **** /**
  57:libcanard/drivers/stm32/canard_stm32.h ****  * The interface can be initialized in either of these modes.
  58:libcanard/drivers/stm32/canard_stm32.h ****  *
  59:libcanard/drivers/stm32/canard_stm32.h ****  * The Silent mode is useful for automatic CAN bit rate detection, where the interface is initializ
  60:libcanard/drivers/stm32/canard_stm32.h ****  * arbitrarily guessed CAN bit rate (typically either 1 Mbps, 500 Kbps, 250 Kbps, or 125 Kbps, thes
  61:libcanard/drivers/stm32/canard_stm32.h ****  * standard values defined by the UAVCAN specification), and the bus is then listened for 1 second 
  62:libcanard/drivers/stm32/canard_stm32.h ****  * determine whether the bit rate was guessed correctly. It is paramount to use the silent mode in 
ARM GAS  /tmp/ccUNHGxP.s 			page 6


  63:libcanard/drivers/stm32/canard_stm32.h ****  * as to not interfere with ongoing communications on the bus if the guess was incorrect.
  64:libcanard/drivers/stm32/canard_stm32.h ****  *
  65:libcanard/drivers/stm32/canard_stm32.h ****  * The automatic TX abort on error mode should be used during dynamic node ID allocation. The reaso
  66:libcanard/drivers/stm32/canard_stm32.h ****  * is well explained in the UAVCAN specification, please read it.
  67:libcanard/drivers/stm32/canard_stm32.h ****  *
  68:libcanard/drivers/stm32/canard_stm32.h ****  * The normal mode should be used for all other use cases, particularly for the normal operation of
  69:libcanard/drivers/stm32/canard_stm32.h ****  * hence the name.
  70:libcanard/drivers/stm32/canard_stm32.h ****  */
  71:libcanard/drivers/stm32/canard_stm32.h **** typedef enum
  72:libcanard/drivers/stm32/canard_stm32.h **** {
  73:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeNormal,                         //!< Normal mode
  74:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeSilent,                         //!< Do not affect the bus, only listen
  75:libcanard/drivers/stm32/canard_stm32.h ****     CanardSTM32IfaceModeAutomaticTxAbortOnError         //!< Abort pending TX if a bus error has oc
  76:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32IfaceMode;
  77:libcanard/drivers/stm32/canard_stm32.h **** 
  78:libcanard/drivers/stm32/canard_stm32.h **** /**
  79:libcanard/drivers/stm32/canard_stm32.h ****  * Interface statistics; these values can be queried using a dedicated API call.
  80:libcanard/drivers/stm32/canard_stm32.h ****  */
  81:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
  82:libcanard/drivers/stm32/canard_stm32.h **** {
  83:libcanard/drivers/stm32/canard_stm32.h ****     uint64_t rx_overflow_count;
  84:libcanard/drivers/stm32/canard_stm32.h ****     uint64_t error_count;
  85:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32Stats;
  86:libcanard/drivers/stm32/canard_stm32.h **** 
  87:libcanard/drivers/stm32/canard_stm32.h **** /**
  88:libcanard/drivers/stm32/canard_stm32.h ****  * ID and Mask of a hardware acceptance filter.
  89:libcanard/drivers/stm32/canard_stm32.h ****  * The ID and Mask fields support flags @ref CANARD_CAN_FRAME_EFF and @ref CANARD_CAN_FRAME_RTR.
  90:libcanard/drivers/stm32/canard_stm32.h ****  */
  91:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
  92:libcanard/drivers/stm32/canard_stm32.h **** {
  93:libcanard/drivers/stm32/canard_stm32.h ****     uint32_t id;
  94:libcanard/drivers/stm32/canard_stm32.h ****     uint32_t mask;
  95:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32AcceptanceFilterConfiguration;
  96:libcanard/drivers/stm32/canard_stm32.h **** 
  97:libcanard/drivers/stm32/canard_stm32.h **** /**
  98:libcanard/drivers/stm32/canard_stm32.h ****  * These parameters define the timings of the CAN controller.
  99:libcanard/drivers/stm32/canard_stm32.h ****  * Please refer to the documentation of the bxCAN macrocell for explanation.
 100:libcanard/drivers/stm32/canard_stm32.h ****  * These values can be computed by the developed beforehand if ROM size is of a concern,
 101:libcanard/drivers/stm32/canard_stm32.h ****  * or they can be computed at run time using the function defined below.
 102:libcanard/drivers/stm32/canard_stm32.h ****  */
 103:libcanard/drivers/stm32/canard_stm32.h **** typedef struct
 104:libcanard/drivers/stm32/canard_stm32.h **** {
 105:libcanard/drivers/stm32/canard_stm32.h ****     uint16_t bit_rate_prescaler;                        /// [1, 1024]
 106:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bit_segment_1;                              /// [1, 16]
 107:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bit_segment_2;                              /// [1, 8]
 108:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t max_resynchronization_jump_width;           /// [1, 4] (recommended value is 1)
 109:libcanard/drivers/stm32/canard_stm32.h **** } CanardSTM32CANTimings;
 110:libcanard/drivers/stm32/canard_stm32.h **** 
 111:libcanard/drivers/stm32/canard_stm32.h **** /**
 112:libcanard/drivers/stm32/canard_stm32.h ****  * Initializes the CAN controller at the specified bit rate.
 113:libcanard/drivers/stm32/canard_stm32.h ****  * The mode can be either normal, silent, or auto-abort on error;
 114:libcanard/drivers/stm32/canard_stm32.h ****  * in silent mode the controller will be only listening, not affecting the state of the bus;
 115:libcanard/drivers/stm32/canard_stm32.h ****  * in the auto abort mode the controller will cancel the pending transmissions if a bus error is en
 116:libcanard/drivers/stm32/canard_stm32.h ****  * The auto abort mode is needed for dynamic node ID allocation procedure; please refer to the UAVC
 117:libcanard/drivers/stm32/canard_stm32.h ****  * for more information about this topic.
 118:libcanard/drivers/stm32/canard_stm32.h ****  *
 119:libcanard/drivers/stm32/canard_stm32.h ****  * This function can be invoked any number of times; every invocation re-initializes everything fro
ARM GAS  /tmp/ccUNHGxP.s 			page 7


 120:libcanard/drivers/stm32/canard_stm32.h ****  *
 121:libcanard/drivers/stm32/canard_stm32.h ****  * WARNING: The clock of the CAN module must be enabled before this function is invoked!
 122:libcanard/drivers/stm32/canard_stm32.h ****  *          If CAN2 is used, CAN1 must be also enabled!
 123:libcanard/drivers/stm32/canard_stm32.h ****  *
 124:libcanard/drivers/stm32/canard_stm32.h ****  * WARNING: The driver is not thread-safe!
 125:libcanard/drivers/stm32/canard_stm32.h ****  *          It does not use IRQ or critical sections though, so it is safe to invoke its API functi
 126:libcanard/drivers/stm32/canard_stm32.h ****  *          IRQ context from the application.
 127:libcanard/drivers/stm32/canard_stm32.h ****  *
 128:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               Success
 129:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 130:libcanard/drivers/stm32/canard_stm32.h ****  */
 131:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Init(const CanardSTM32CANTimings* const timings,
 132:libcanard/drivers/stm32/canard_stm32.h ****                         const CanardSTM32IfaceMode iface_mode);
 133:libcanard/drivers/stm32/canard_stm32.h **** 
 134:libcanard/drivers/stm32/canard_stm32.h **** /**
 135:libcanard/drivers/stm32/canard_stm32.h ****  * Pushes one frame into the TX buffer, if there is space.
 136:libcanard/drivers/stm32/canard_stm32.h ****  * Note that proper care is taken to ensure that no inner priority inversion is taking place.
 137:libcanard/drivers/stm32/canard_stm32.h ****  * This function does never block.
 138:libcanard/drivers/stm32/canard_stm32.h ****  *
 139:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      1               Transmitted successfully
 140:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               No space in the buffer
 141:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 142:libcanard/drivers/stm32/canard_stm32.h ****  */
 143:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Transmit(const CanardCANFrame* const frame);
 144:libcanard/drivers/stm32/canard_stm32.h **** 
 145:libcanard/drivers/stm32/canard_stm32.h **** /**
 146:libcanard/drivers/stm32/canard_stm32.h ****  * Reads one frame from the hardware RX FIFO, unless all FIFO are empty.
 147:libcanard/drivers/stm32/canard_stm32.h ****  * This function does never block.
 148:libcanard/drivers/stm32/canard_stm32.h ****  *
 149:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      1               Read successfully
 150:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               The buffer is empty
 151:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 152:libcanard/drivers/stm32/canard_stm32.h ****  */
 153:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32Receive(CanardCANFrame* const out_frame);
 154:libcanard/drivers/stm32/canard_stm32.h **** 
 155:libcanard/drivers/stm32/canard_stm32.h **** /**
 156:libcanard/drivers/stm32/canard_stm32.h ****  * Sets up acceptance filters according to the provided list of ID and masks.
 157:libcanard/drivers/stm32/canard_stm32.h ****  * Note that when the interface is reinitialized, hardware acceptance filters are reset.
 158:libcanard/drivers/stm32/canard_stm32.h ****  * Also note that during filter reconfiguration, some RX frames may be lost.
 159:libcanard/drivers/stm32/canard_stm32.h ****  *
 160:libcanard/drivers/stm32/canard_stm32.h ****  * Setting zero filters will result in rejection of all frames.
 161:libcanard/drivers/stm32/canard_stm32.h ****  * In order to accept all frames, set one filter with ID = Mask = 0, which is also the default conf
 162:libcanard/drivers/stm32/canard_stm32.h ****  *
 163:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      0               Success
 164:libcanard/drivers/stm32/canard_stm32.h ****  * @retval      negative        Error
 165:libcanard/drivers/stm32/canard_stm32.h ****  */
 166:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32ConfigureAcceptanceFilters(const CanardSTM32AcceptanceFilterConfiguration* const
 167:libcanard/drivers/stm32/canard_stm32.h ****                                               const uint8_t num_filter_configs);
 168:libcanard/drivers/stm32/canard_stm32.h **** 
 169:libcanard/drivers/stm32/canard_stm32.h **** /**
 170:libcanard/drivers/stm32/canard_stm32.h ****  * Returns the running interface statistics.
 171:libcanard/drivers/stm32/canard_stm32.h ****  */
 172:libcanard/drivers/stm32/canard_stm32.h **** CanardSTM32Stats canardSTM32GetStats(void);
 173:libcanard/drivers/stm32/canard_stm32.h **** 
 174:libcanard/drivers/stm32/canard_stm32.h **** /**
 175:libcanard/drivers/stm32/canard_stm32.h ****  * Given the rate of the clock supplied to the bxCAN macrocell (typically PCLK1) and the desired bi
 176:libcanard/drivers/stm32/canard_stm32.h ****  * this function iteratively solves for the best possible timing settings. The CAN bus timing param
ARM GAS  /tmp/ccUNHGxP.s 			page 8


 177:libcanard/drivers/stm32/canard_stm32.h ****  * such as the sample point location, the number of time quantas per bit, etc., are optimized accor
 178:libcanard/drivers/stm32/canard_stm32.h ****  * recommendations provided in the specifications of UAVCAN, DeviceNet, and CANOpen.
 179:libcanard/drivers/stm32/canard_stm32.h ****  *
 180:libcanard/drivers/stm32/canard_stm32.h ****  * Unless noted otherwise, all units are SI units; particularly, frequency is specified in hertz.
 181:libcanard/drivers/stm32/canard_stm32.h ****  *
 182:libcanard/drivers/stm32/canard_stm32.h ****  * The implementation is adapted from libuavcan.
 183:libcanard/drivers/stm32/canard_stm32.h ****  *
 184:libcanard/drivers/stm32/canard_stm32.h ****  * This function is defined in the header in order to encourage the linker to discard it if it is n
 185:libcanard/drivers/stm32/canard_stm32.h ****  *
 186:libcanard/drivers/stm32/canard_stm32.h ****  * @retval 0            Success
 187:libcanard/drivers/stm32/canard_stm32.h ****  * @retval negative     Solution could not be found for the provided inputs.
 188:libcanard/drivers/stm32/canard_stm32.h ****  */
 189:libcanard/drivers/stm32/canard_stm32.h **** static inline
 190:libcanard/drivers/stm32/canard_stm32.h **** int16_t canardSTM32ComputeCANTimings(const uint32_t peripheral_clock_rate,
 191:libcanard/drivers/stm32/canard_stm32.h ****                                      const uint32_t target_bitrate,
 192:libcanard/drivers/stm32/canard_stm32.h ****                                      CanardSTM32CANTimings* const out_timings)
 193:libcanard/drivers/stm32/canard_stm32.h **** {
 194:libcanard/drivers/stm32/canard_stm32.h ****     if (target_bitrate < 1000)
 195:libcanard/drivers/stm32/canard_stm32.h ****     {
 196:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 197:libcanard/drivers/stm32/canard_stm32.h ****     }
 198:libcanard/drivers/stm32/canard_stm32.h **** 
 199:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(out_timings != NULL);  // NOLINT
 200:libcanard/drivers/stm32/canard_stm32.h ****     memset(out_timings, 0, sizeof(*out_timings));
 128              		.loc 2 200 0
 129 0008 0023     		movs	r3, #0
 130 000a 0293     		str	r3, [sp, #8]
 131 000c ADF80C30 		strh	r3, [sp, #12]	@ movhi
 132              	.LVL13:
 201:libcanard/drivers/stm32/canard_stm32.h **** 
 202:libcanard/drivers/stm32/canard_stm32.h ****     /*
 203:libcanard/drivers/stm32/canard_stm32.h ****      * Hardware configuration
 204:libcanard/drivers/stm32/canard_stm32.h ****      */
 205:libcanard/drivers/stm32/canard_stm32.h ****     static const uint8_t MaxBS1 = 16;
 206:libcanard/drivers/stm32/canard_stm32.h ****     static const uint8_t MaxBS2 = 8;
 207:libcanard/drivers/stm32/canard_stm32.h **** 
 208:libcanard/drivers/stm32/canard_stm32.h ****     /*
 209:libcanard/drivers/stm32/canard_stm32.h ****      * Ref. "Automatic Baudrate Detection in CANopen Networks", U. Koppe, MicroControl GmbH & Co. K
 210:libcanard/drivers/stm32/canard_stm32.h ****      *      CAN in Automation, 2003
 211:libcanard/drivers/stm32/canard_stm32.h ****      *
 212:libcanard/drivers/stm32/canard_stm32.h ****      * According to the source, optimal quanta per bit are:
 213:libcanard/drivers/stm32/canard_stm32.h ****      *   Bitrate        Optimal Maximum
 214:libcanard/drivers/stm32/canard_stm32.h ****      *   1000 kbps      8       10
 215:libcanard/drivers/stm32/canard_stm32.h ****      *   500  kbps      16      17
 216:libcanard/drivers/stm32/canard_stm32.h ****      *   250  kbps      16      17
 217:libcanard/drivers/stm32/canard_stm32.h ****      *   125  kbps      16      17
 218:libcanard/drivers/stm32/canard_stm32.h ****      */
 219:libcanard/drivers/stm32/canard_stm32.h ****     const uint8_t max_quanta_per_bit = (uint8_t)((target_bitrate >= 1000000) ? 10 : 17);    // NOLI
 220:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(max_quanta_per_bit <= (MaxBS1 + MaxBS2));
 221:libcanard/drivers/stm32/canard_stm32.h **** 
 222:libcanard/drivers/stm32/canard_stm32.h ****     static const uint16_t MaxSamplePointLocationPermill = 900;
 223:libcanard/drivers/stm32/canard_stm32.h **** 
 224:libcanard/drivers/stm32/canard_stm32.h ****     /*
 225:libcanard/drivers/stm32/canard_stm32.h ****      * Computing (prescaler * BS):
 226:libcanard/drivers/stm32/canard_stm32.h ****      *   BITRATE = 1 / (PRESCALER * (1 / PCLK) * (1 + BS1 + BS2))       -- See the Reference Manual
 227:libcanard/drivers/stm32/canard_stm32.h ****      *   BITRATE = PCLK / (PRESCALER * (1 + BS1 + BS2))                 -- Simplified
 228:libcanard/drivers/stm32/canard_stm32.h ****      * let:
ARM GAS  /tmp/ccUNHGxP.s 			page 9


 229:libcanard/drivers/stm32/canard_stm32.h ****      *   BS = 1 + BS1 + BS2                                             -- Number of time quanta pe
 230:libcanard/drivers/stm32/canard_stm32.h ****      *   PRESCALER_BS = PRESCALER * BS
 231:libcanard/drivers/stm32/canard_stm32.h ****      * ==>
 232:libcanard/drivers/stm32/canard_stm32.h ****      *   PRESCALER_BS = PCLK / BITRATE
 233:libcanard/drivers/stm32/canard_stm32.h ****      */
 234:libcanard/drivers/stm32/canard_stm32.h ****     const uint32_t prescaler_bs = peripheral_clock_rate / target_bitrate;
 133              		.loc 2 234 0
 134 0010 424C     		ldr	r4, .L34
 135 0012 A4FB0034 		umull	r3, r4, r4, r0
 136 0016 A40C     		lsrs	r4, r4, #18
 137              	.LVL14:
 235:libcanard/drivers/stm32/canard_stm32.h **** 
 236:libcanard/drivers/stm32/canard_stm32.h ****     /*
 237:libcanard/drivers/stm32/canard_stm32.h ****      * Searching for such prescaler value so that the number of quanta per bit is highest.
 238:libcanard/drivers/stm32/canard_stm32.h ****      */
 239:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs1_bs2_sum = (uint8_t)(max_quanta_per_bit - 1);    // NOLINT
 138              		.loc 2 239 0
 139 0018 0923     		movs	r3, #9
 140              	.LVL15:
 141              	.L12:
 240:libcanard/drivers/stm32/canard_stm32.h **** 
 241:libcanard/drivers/stm32/canard_stm32.h ****     while ((prescaler_bs % (1U + bs1_bs2_sum)) != 0)
 142              		.loc 2 241 0
 143 001a 591C     		adds	r1, r3, #1
 144 001c B4FBF1F2 		udiv	r2, r4, r1
 145 0020 01FB1242 		mls	r2, r1, r2, r4
 146 0024 22B1     		cbz	r2, .L30
 242:libcanard/drivers/stm32/canard_stm32.h ****     {
 243:libcanard/drivers/stm32/canard_stm32.h ****         if (bs1_bs2_sum <= 2)
 147              		.loc 2 243 0
 148 0026 022B     		cmp	r3, #2
 149 0028 73D9     		bls	.L24
 244:libcanard/drivers/stm32/canard_stm32.h ****         {
 245:libcanard/drivers/stm32/canard_stm32.h ****             return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;          // No solution
 246:libcanard/drivers/stm32/canard_stm32.h ****         }
 247:libcanard/drivers/stm32/canard_stm32.h ****         bs1_bs2_sum--;
 150              		.loc 2 247 0
 151 002a 013B     		subs	r3, r3, #1
 152              	.LVL16:
 153 002c DBB2     		uxtb	r3, r3
 154              	.LVL17:
 155 002e F4E7     		b	.L12
 156              	.L30:
 248:libcanard/drivers/stm32/canard_stm32.h ****     }
 249:libcanard/drivers/stm32/canard_stm32.h **** 
 250:libcanard/drivers/stm32/canard_stm32.h ****     const uint32_t prescaler = prescaler_bs / (1U + bs1_bs2_sum);
 157              		.loc 2 250 0
 158 0030 B4FBF1F1 		udiv	r1, r4, r1
 159              	.LVL18:
 251:libcanard/drivers/stm32/canard_stm32.h ****     if ((prescaler < 1U) || (prescaler > 1024U))
 160              		.loc 2 251 0
 161 0034 4A1E     		subs	r2, r1, #1
 162 0036 B2F5806F 		cmp	r2, #1024
 163 003a 6CD2     		bcs	.L25
 252:libcanard/drivers/stm32/canard_stm32.h ****     {
 253:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;              // No solution
 254:libcanard/drivers/stm32/canard_stm32.h ****     }
ARM GAS  /tmp/ccUNHGxP.s 			page 10


 255:libcanard/drivers/stm32/canard_stm32.h **** 
 256:libcanard/drivers/stm32/canard_stm32.h ****     /*
 257:libcanard/drivers/stm32/canard_stm32.h ****      * Now we have a constraint: (BS1 + BS2) == bs1_bs2_sum.
 258:libcanard/drivers/stm32/canard_stm32.h ****      * We need to find such values so that the sample point is as close as possible to the optimal 
 259:libcanard/drivers/stm32/canard_stm32.h ****      * which is 87.5%, which is 7/8.
 260:libcanard/drivers/stm32/canard_stm32.h ****      *
 261:libcanard/drivers/stm32/canard_stm32.h ****      *   Solve[(1 + bs1)/(1 + bs1 + bs2) == 7/8, bs2]  (* Where 7/8 is 0.875, the recommended sampl
 262:libcanard/drivers/stm32/canard_stm32.h ****      *   {{bs2 -> (1 + bs1)/7}}
 263:libcanard/drivers/stm32/canard_stm32.h ****      *
 264:libcanard/drivers/stm32/canard_stm32.h ****      * Hence:
 265:libcanard/drivers/stm32/canard_stm32.h ****      *   bs2 = (1 + bs1) / 7
 266:libcanard/drivers/stm32/canard_stm32.h ****      *   bs1 = (7 * bs1_bs2_sum - 1) / 8
 267:libcanard/drivers/stm32/canard_stm32.h ****      *
 268:libcanard/drivers/stm32/canard_stm32.h ****      * Sample point location can be computed as follows:
 269:libcanard/drivers/stm32/canard_stm32.h ****      *   Sample point location = (1 + bs1) / (1 + bs1 + bs2)
 270:libcanard/drivers/stm32/canard_stm32.h ****      *
 271:libcanard/drivers/stm32/canard_stm32.h ****      * Since the optimal solution is so close to the maximum, we prepare two solutions, and then pi
 272:libcanard/drivers/stm32/canard_stm32.h ****      *   - With rounding to nearest
 273:libcanard/drivers/stm32/canard_stm32.h ****      *   - With rounding to zero
 274:libcanard/drivers/stm32/canard_stm32.h ****      */
 275:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs1 = (uint8_t)(((7 * bs1_bs2_sum - 1) + 4) / 8);       // Trying rounding to nearest f
 164              		.loc 2 275 0
 165 003c C3EBC306 		rsb	r6, r3, r3, lsl #3
 166 0040 F21C     		adds	r2, r6, #3
 167 0042 22D4     		bmi	.L31
 168              	.L15:
 169 0044 D210     		asrs	r2, r2, #3
 170 0046 D5B2     		uxtb	r5, r2
 171              	.LVL19:
 276:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs2 = (uint8_t)(bs1_bs2_sum - bs1);  // NOLINT
 172              		.loc 2 276 0
 173 0048 5F1B     		subs	r7, r3, r5
 174 004a FFB2     		uxtb	r7, r7
 175              	.LVL20:
 277:libcanard/drivers/stm32/canard_stm32.h ****     CANARD_ASSERT(bs1_bs2_sum > bs1);
 176              		.loc 2 277 0
 177 004c AB42     		cmp	r3, r5
 178 004e 1ED9     		bls	.L32
 179              	.LBB13:
 278:libcanard/drivers/stm32/canard_stm32.h **** 
 279:libcanard/drivers/stm32/canard_stm32.h ****     {
 280:libcanard/drivers/stm32/canard_stm32.h ****         const uint16_t sample_point_permill = (uint16_t)(1000U * (1U + bs1) / (1U + bs1 + bs2));  /
 180              		.loc 2 280 0
 181 0050 D2B2     		uxtb	r2, r2
 182 0052 4FF47A74 		mov	r4, #1000
 183              	.LVL21:
 184 0056 02FB0444 		mla	r4, r2, r4, r4
 185 005a 3A44     		add	r2, r2, r7
 186 005c 0132     		adds	r2, r2, #1
 187 005e B4FBF2F2 		udiv	r2, r4, r2
 188 0062 92B2     		uxth	r2, r2
 189              	.LVL22:
 281:libcanard/drivers/stm32/canard_stm32.h **** 
 282:libcanard/drivers/stm32/canard_stm32.h ****         if (sample_point_permill > MaxSamplePointLocationPermill)   // Strictly more!
 190              		.loc 2 282 0
 191 0064 B2F5617F 		cmp	r2, #900
 192 0068 05D9     		bls	.L17
ARM GAS  /tmp/ccUNHGxP.s 			page 11


 283:libcanard/drivers/stm32/canard_stm32.h ****         {
 284:libcanard/drivers/stm32/canard_stm32.h ****             bs1 = (uint8_t)((7 * bs1_bs2_sum - 1) / 8);             // Nope, too far; now rounding 
 193              		.loc 2 284 0
 194 006a 751E     		subs	r5, r6, #1
 195              	.LVL23:
 196 006c 16D4     		bmi	.L33
 197              	.L18:
 198 006e C5F3C705 		ubfx	r5, r5, #3, #8
 199              	.LVL24:
 285:libcanard/drivers/stm32/canard_stm32.h ****             bs2 = (uint8_t)(bs1_bs2_sum - bs1);
 200              		.loc 2 285 0
 201 0072 5B1B     		subs	r3, r3, r5
 202              	.LVL25:
 203 0074 DFB2     		uxtb	r7, r3
 204              	.LVL26:
 205              	.L17:
 206              	.LBE13:
 286:libcanard/drivers/stm32/canard_stm32.h ****         }
 287:libcanard/drivers/stm32/canard_stm32.h ****     }
 288:libcanard/drivers/stm32/canard_stm32.h **** 
 289:libcanard/drivers/stm32/canard_stm32.h ****     const bool valid = (bs1 >= 1) && (bs1 <= MaxBS1) && (bs2 >= 1) && (bs2 <= MaxBS2);
 207              		.loc 2 289 0
 208 0076 6B1E     		subs	r3, r5, #1
 209 0078 DBB2     		uxtb	r3, r3
 210 007a 0F2B     		cmp	r3, #15
 211 007c 10D8     		bhi	.L26
 212 007e 002F     		cmp	r7, #0
 213 0080 3CD0     		beq	.L27
 214 0082 082F     		cmp	r7, #8
 215 0084 3CD9     		bls	.L28
 216 0086 0022     		movs	r2, #0
 217              	.LVL27:
 218 0088 0BE0     		b	.L19
 219              	.LVL28:
 220              	.L31:
 275:libcanard/drivers/stm32/canard_stm32.h ****     uint8_t bs2 = (uint8_t)(bs1_bs2_sum - bs1);  // NOLINT
 221              		.loc 2 275 0
 222 008a 0732     		adds	r2, r2, #7
 223 008c DAE7     		b	.L15
 224              	.LVL29:
 225              	.L32:
 277:libcanard/drivers/stm32/canard_stm32.h **** 
 226              		.loc 2 277 0
 227 008e 244B     		ldr	r3, .L34+4
 228              	.LVL30:
 229 0090 244A     		ldr	r2, .L34+8
 230 0092 40F21511 		movw	r1, #277
 231              	.LVL31:
 232 0096 2448     		ldr	r0, .L34+12
 233              	.LVL32:
 234 0098 FFF7FEFF 		bl	__assert_func
 235              	.LVL33:
 236              	.L33:
 237              	.LBB14:
 284:libcanard/drivers/stm32/canard_stm32.h ****             bs2 = (uint8_t)(bs1_bs2_sum - bs1);
 238              		.loc 2 284 0
 239 009c 0735     		adds	r5, r5, #7
ARM GAS  /tmp/ccUNHGxP.s 			page 12


 240 009e E6E7     		b	.L18
 241              	.LVL34:
 242              	.L26:
 243              	.LBE14:
 244              		.loc 2 289 0
 245 00a0 0022     		movs	r2, #0
 246              	.LVL35:
 247              	.L19:
 290:libcanard/drivers/stm32/canard_stm32.h **** 
 291:libcanard/drivers/stm32/canard_stm32.h ****     /*
 292:libcanard/drivers/stm32/canard_stm32.h ****      * Final validation
 293:libcanard/drivers/stm32/canard_stm32.h ****      * Helpful Python:
 294:libcanard/drivers/stm32/canard_stm32.h ****      * def sample_point_from_btr(x):
 295:libcanard/drivers/stm32/canard_stm32.h ****      *     assert 0b0011110010000000111111000000000 & x == 0
 296:libcanard/drivers/stm32/canard_stm32.h ****      *     ts2,ts1,brp = (x>>20)&7, (x>>16)&15, x&511
 297:libcanard/drivers/stm32/canard_stm32.h ****      *     return (1+ts1+1)/(1+ts1+1+ts2+1)
 298:libcanard/drivers/stm32/canard_stm32.h ****      */
 299:libcanard/drivers/stm32/canard_stm32.h ****     if ((target_bitrate != (peripheral_clock_rate / (prescaler * (1U + bs1 + bs2)))) ||
 248              		.loc 2 299 0
 249 00a2 EB19     		adds	r3, r5, r7
 250 00a4 03FB0113 		mla	r3, r3, r1, r1
 251 00a8 B0FBF3F0 		udiv	r0, r0, r3
 252              	.LVL36:
 253 00ac 1F4B     		ldr	r3, .L34+16
 254 00ae 9842     		cmp	r0, r3
 255 00b0 28D1     		bne	.L20
 256 00b2 3AB3     		cbz	r2, .L20
 300:libcanard/drivers/stm32/canard_stm32.h ****         !valid)
 301:libcanard/drivers/stm32/canard_stm32.h ****     {
 302:libcanard/drivers/stm32/canard_stm32.h ****         // This actually means that the algorithm has a logic error, hence assert(0).
 303:libcanard/drivers/stm32/canard_stm32.h ****         CANARD_ASSERT(0);  // NOLINT
 304:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 305:libcanard/drivers/stm32/canard_stm32.h ****     }
 306:libcanard/drivers/stm32/canard_stm32.h **** 
 307:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_rate_prescaler = (uint16_t) prescaler;
 257              		.loc 2 307 0
 258 00b4 ADF80810 		strh	r1, [sp, #8]	@ movhi
 308:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->max_resynchronization_jump_width = 1;      // One is recommended by UAVCAN, CANOpe
 259              		.loc 2 308 0
 260 00b8 0123     		movs	r3, #1
 261 00ba 8DF80C30 		strb	r3, [sp, #12]
 309:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_segment_1 = bs1;
 262              		.loc 2 309 0
 263 00be 8DF80A50 		strb	r5, [sp, #10]
 310:libcanard/drivers/stm32/canard_stm32.h ****     out_timings->bit_segment_2 = bs2;
 264              		.loc 2 310 0
 265 00c2 8DF80B70 		strb	r7, [sp, #11]
 311:libcanard/drivers/stm32/canard_stm32.h **** 
 312:libcanard/drivers/stm32/canard_stm32.h ****     return 0;
 266              		.loc 2 312 0
 267 00c6 0023     		movs	r3, #0
 268              	.LVL37:
 269              	.L13:
 270              	.LBE12:
 271              	.LBE11:
  92:Src/uavcan.c  ****     if (result)
 272              		.loc 1 92 0
ARM GAS  /tmp/ccUNHGxP.s 			page 13


 273 00c8 03B1     		cbz	r3, .L22
  93:Src/uavcan.c  ****     {
  94:Src/uavcan.c  ****         __ASM volatile("BKPT #01");
 274              		.loc 1 94 0
 275              		.syntax unified
 276              	@ 94 "Src/uavcan.c" 1
 277 00ca 01BE     		BKPT #01
 278              	@ 0 "" 2
 279              		.thumb
 280              		.syntax unified
 281              	.L22:
  95:Src/uavcan.c  ****     }
  96:Src/uavcan.c  ****     result = canardSTM32Init(&timings, CanardSTM32IfaceModeNormal);
 282              		.loc 1 96 0
 283 00cc 0021     		movs	r1, #0
 284 00ce 02A8     		add	r0, sp, #8
 285 00d0 FFF7FEFF 		bl	canardSTM32Init
 286              	.LVL38:
  97:Src/uavcan.c  ****     if (result)
 287              		.loc 1 97 0
 288 00d4 00B1     		cbz	r0, .L23
  98:Src/uavcan.c  ****     {
  99:Src/uavcan.c  ****         __ASM volatile("BKPT #01");
 289              		.loc 1 99 0
 290              		.syntax unified
 291              	@ 99 "Src/uavcan.c" 1
 292 00d6 01BE     		BKPT #01
 293              	@ 0 "" 2
 294              		.thumb
 295              		.syntax unified
 296              	.L23:
 100:Src/uavcan.c  ****     }
 101:Src/uavcan.c  ****  
 102:Src/uavcan.c  ****     canardInit(&g_canard,                         // Uninitialized library instance
 297              		.loc 1 102 0
 298 00d8 154C     		ldr	r4, .L34+20
 299 00da 0023     		movs	r3, #0
 300 00dc 0193     		str	r3, [sp, #4]
 301 00de 154B     		ldr	r3, .L34+24
 302 00e0 0093     		str	r3, [sp]
 303 00e2 154B     		ldr	r3, .L34+28
 304 00e4 4FF48062 		mov	r2, #1024
 305 00e8 1449     		ldr	r1, .L34+32
 306 00ea 2046     		mov	r0, r4
 307              	.LVL39:
 308 00ec FFF7FEFF 		bl	canardInit
 309              	.LVL40:
 103:Src/uavcan.c  ****                g_canard_memory_pool,              // Raw memory chunk used for dynamic allocation
 104:Src/uavcan.c  ****                sizeof(g_canard_memory_pool),      // Size of the above, in bytes
 105:Src/uavcan.c  ****                onTransferReceived,                // Callback, see CanardOnTransferReception
 106:Src/uavcan.c  ****                shouldAcceptTransfer,              // Callback, see CanardShouldAcceptTransfer
 107:Src/uavcan.c  ****                NULL);
 108:Src/uavcan.c  ****  
 109:Src/uavcan.c  ****     canardSetLocalNodeID(&g_canard, 10);
 310              		.loc 1 109 0
 311 00f0 0A21     		movs	r1, #10
 312 00f2 2046     		mov	r0, r4
ARM GAS  /tmp/ccUNHGxP.s 			page 14


 313 00f4 FFF7FEFF 		bl	canardSetLocalNodeID
 314              	.LVL41:
 110:Src/uavcan.c  **** }
 315              		.loc 1 110 0
 316 00f8 05B0     		add	sp, sp, #20
 317              	.LCFI2:
 318              		.cfi_remember_state
 319              		.cfi_def_cfa_offset 20
 320              		@ sp needed
 321 00fa F0BD     		pop	{r4, r5, r6, r7, pc}
 322              	.LVL42:
 323              	.L27:
 324              	.LCFI3:
 325              		.cfi_restore_state
 326              	.LBB16:
 327              	.LBB15:
 289:libcanard/drivers/stm32/canard_stm32.h **** 
 328              		.loc 2 289 0
 329 00fc 0022     		movs	r2, #0
 330              	.LVL43:
 331 00fe D0E7     		b	.L19
 332              	.LVL44:
 333              	.L28:
 334 0100 0122     		movs	r2, #1
 335              	.LVL45:
 336 0102 CEE7     		b	.L19
 337              	.LVL46:
 338              	.L20:
 303:libcanard/drivers/stm32/canard_stm32.h ****         return -CANARD_STM32_ERROR_UNSUPPORTED_BIT_RATE;
 339              		.loc 2 303 0
 340 0104 0E4B     		ldr	r3, .L34+36
 341 0106 074A     		ldr	r2, .L34+8
 342              	.LVL47:
 343 0108 40F22F11 		movw	r1, #303
 344              	.LVL48:
 345 010c 0648     		ldr	r0, .L34+12
 346 010e FFF7FEFF 		bl	__assert_func
 347              	.LVL49:
 348              	.L24:
 245:libcanard/drivers/stm32/canard_stm32.h ****         }
 349              		.loc 2 245 0
 350 0112 0C4B     		ldr	r3, .L34+40
 351              	.LVL50:
 352 0114 D8E7     		b	.L13
 353              	.LVL51:
 354              	.L25:
 253:libcanard/drivers/stm32/canard_stm32.h ****     }
 355              		.loc 2 253 0
 356 0116 0B4B     		ldr	r3, .L34+40
 357              	.LVL52:
 358 0118 D6E7     		b	.L13
 359              	.L35:
 360 011a 00BF     		.align	2
 361              	.L34:
 362 011c 83DE1B43 		.word	1125899907
 363 0120 00000000 		.word	.LC0
 364 0124 00000000 		.word	.LANCHOR0
ARM GAS  /tmp/ccUNHGxP.s 			page 15


 365 0128 14000000 		.word	.LC1
 366 012c 40420F00 		.word	1000000
 367 0130 00000000 		.word	.LANCHOR2
 368 0134 00000000 		.word	shouldAcceptTransfer
 369 0138 00000000 		.word	onTransferReceived
 370 013c 00000000 		.word	.LANCHOR1
 371 0140 3C000000 		.word	.LC2
 372 0144 18FCFFFF 		.word	-1000
 373              	.LBE15:
 374              	.LBE16:
 375              		.cfi_endproc
 376              	.LFE68:
 378              		.section	.text.sendCanard,"ax",%progbits
 379              		.align	1
 380              		.global	sendCanard
 381              		.syntax unified
 382              		.thumb
 383              		.thumb_func
 384              		.fpu softvfp
 386              	sendCanard:
 387              	.LFB69:
 111:Src/uavcan.c  **** 
 112:Src/uavcan.c  **** void sendCanard(void)
 113:Src/uavcan.c  **** {
 388              		.loc 1 113 0
 389              		.cfi_startproc
 390              		@ args = 0, pretend = 0, frame = 0
 391              		@ frame_needed = 0, uses_anonymous_args = 0
 392 0000 08B5     		push	{r3, lr}
 393              	.LCFI4:
 394              		.cfi_def_cfa_offset 8
 395              		.cfi_offset 3, -8
 396              		.cfi_offset 14, -4
 114:Src/uavcan.c  ****   const CanardCANFrame* txf = canardPeekTxQueue(&g_canard); 
 397              		.loc 1 114 0
 398 0002 0A48     		ldr	r0, .L44
 399 0004 FFF7FEFF 		bl	canardPeekTxQueue
 400              	.LVL53:
 115:Src/uavcan.c  ****   while(txf)
 401              		.loc 1 115 0
 402 0008 04E0     		b	.L37
 403              	.LVL54:
 404              	.L43:
 405              	.LBB17:
 116:Src/uavcan.c  ****     {
 117:Src/uavcan.c  ****         const int tx_res = canardSTM32Transmit(txf);
 118:Src/uavcan.c  ****         if (tx_res < 0)                  // Failure - drop the frame and report
 119:Src/uavcan.c  ****         {
 120:Src/uavcan.c  ****             __ASM volatile("BKPT #01");  // TODO: handle the error properly
 406              		.loc 1 120 0
 407              		.syntax unified
 408              	@ 120 "Src/uavcan.c" 1
 409 000a 01BE     		BKPT #01
 410              	@ 0 "" 2
 411              		.thumb
 412              		.syntax unified
 413 000c 07E0     		b	.L38
ARM GAS  /tmp/ccUNHGxP.s 			page 16


 414              	.LVL55:
 415              	.L39:
 121:Src/uavcan.c  ****         }
 122:Src/uavcan.c  ****         if(tx_res > 0)
 123:Src/uavcan.c  ****         {
 124:Src/uavcan.c  ****             canardPopTxQueue(&g_canard);
 125:Src/uavcan.c  ****         }
 126:Src/uavcan.c  ****         txf = canardPeekTxQueue(&g_canard); 
 416              		.loc 1 126 0
 417 000e 0748     		ldr	r0, .L44
 418 0010 FFF7FEFF 		bl	canardPeekTxQueue
 419              	.LVL56:
 420              	.L37:
 421              	.LBE17:
 115:Src/uavcan.c  ****     {
 422              		.loc 1 115 0
 423 0014 48B1     		cbz	r0, .L42
 424              	.LBB18:
 117:Src/uavcan.c  ****         if (tx_res < 0)                  // Failure - drop the frame and report
 425              		.loc 1 117 0
 426 0016 FFF7FEFF 		bl	canardSTM32Transmit
 427              	.LVL57:
 118:Src/uavcan.c  ****         {
 428              		.loc 1 118 0
 429 001a 0028     		cmp	r0, #0
 430 001c F5DB     		blt	.L43
 431              	.L38:
 122:Src/uavcan.c  ****         {
 432              		.loc 1 122 0
 433 001e 0028     		cmp	r0, #0
 434 0020 F5DD     		ble	.L39
 124:Src/uavcan.c  ****         }
 435              		.loc 1 124 0
 436 0022 0248     		ldr	r0, .L44
 437              	.LVL58:
 438 0024 FFF7FEFF 		bl	canardPopTxQueue
 439              	.LVL59:
 440 0028 F1E7     		b	.L39
 441              	.LVL60:
 442              	.L42:
 443              	.LBE18:
 127:Src/uavcan.c  ****     }
 128:Src/uavcan.c  **** }
 444              		.loc 1 128 0
 445 002a 08BD     		pop	{r3, pc}
 446              	.L45:
 447              		.align	2
 448              	.L44:
 449 002c 00000000 		.word	.LANCHOR2
 450              		.cfi_endproc
 451              	.LFE69:
 453              		.section	.text.receiveCanard,"ax",%progbits
 454              		.align	1
 455              		.global	receiveCanard
 456              		.syntax unified
 457              		.thumb
 458              		.thumb_func
ARM GAS  /tmp/ccUNHGxP.s 			page 17


 459              		.fpu softvfp
 461              	receiveCanard:
 462              	.LFB70:
 129:Src/uavcan.c  **** 
 130:Src/uavcan.c  **** void receiveCanard(void)
 131:Src/uavcan.c  **** {
 463              		.loc 1 131 0
 464              		.cfi_startproc
 465              		@ args = 0, pretend = 0, frame = 16
 466              		@ frame_needed = 0, uses_anonymous_args = 0
 467 0000 00B5     		push	{lr}
 468              	.LCFI5:
 469              		.cfi_def_cfa_offset 4
 470              		.cfi_offset 14, -4
 471 0002 85B0     		sub	sp, sp, #20
 472              	.LCFI6:
 473              		.cfi_def_cfa_offset 24
 132:Src/uavcan.c  ****     CanardCANFrame rx_frame;
 133:Src/uavcan.c  ****     int res = canardSTM32Receive(&rx_frame);
 474              		.loc 1 133 0
 475 0004 6846     		mov	r0, sp
 476 0006 FFF7FEFF 		bl	canardSTM32Receive
 477              	.LVL61:
 134:Src/uavcan.c  ****     if(res)
 478              		.loc 1 134 0
 479 000a 10B9     		cbnz	r0, .L49
 480              	.LVL62:
 481              	.L46:
 135:Src/uavcan.c  ****     {
 136:Src/uavcan.c  ****         canardHandleRxFrame(&g_canard, &rx_frame, HAL_GetTick() * 1000);
 137:Src/uavcan.c  ****     }    
 138:Src/uavcan.c  **** }
 482              		.loc 1 138 0
 483 000c 05B0     		add	sp, sp, #20
 484              	.LCFI7:
 485              		.cfi_remember_state
 486              		.cfi_def_cfa_offset 4
 487              		@ sp needed
 488 000e 5DF804FB 		ldr	pc, [sp], #4
 489              	.LVL63:
 490              	.L49:
 491              	.LCFI8:
 492              		.cfi_restore_state
 136:Src/uavcan.c  ****     }    
 493              		.loc 1 136 0
 494 0012 FFF7FEFF 		bl	HAL_GetTick
 495              	.LVL64:
 496 0016 4FF47A72 		mov	r2, #1000
 497 001a 02FB00F2 		mul	r2, r2, r0
 498 001e 0023     		movs	r3, #0
 499 0020 6946     		mov	r1, sp
 500 0022 0248     		ldr	r0, .L50
 501 0024 FFF7FEFF 		bl	canardHandleRxFrame
 502              	.LVL65:
 503              		.loc 1 138 0
 504 0028 F0E7     		b	.L46
 505              	.L51:
ARM GAS  /tmp/ccUNHGxP.s 			page 18


 506 002a 00BF     		.align	2
 507              	.L50:
 508 002c 00000000 		.word	.LANCHOR2
 509              		.cfi_endproc
 510              	.LFE70:
 512              		.global	__aeabi_ui2f
 513              		.global	__aeabi_i2f
 514              		.section	.text.publishCanard,"ax",%progbits
 515              		.align	1
 516              		.global	publishCanard
 517              		.syntax unified
 518              		.thumb
 519              		.thumb_func
 520              		.fpu softvfp
 522              	publishCanard:
 523              	.LFB72:
 139:Src/uavcan.c  **** 
 140:Src/uavcan.c  **** void spinCanard(void)
 141:Src/uavcan.c  **** {  
 142:Src/uavcan.c  ****     static uint32_t spin_time = 0;
 143:Src/uavcan.c  ****     if(HAL_GetTick() < spin_time + CANARD_SPIN_PERIOD) return;  // rate limiting
 144:Src/uavcan.c  ****     spin_time = HAL_GetTick();
 145:Src/uavcan.c  ****     HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_12);   
 146:Src/uavcan.c  ****     
 147:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE];    
 148:Src/uavcan.c  ****     static uint8_t transfer_id = 0;                           // This variable MUST BE STATIC; refe
 149:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);  
 150:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 151:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
 152:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_ID,
 153:Src/uavcan.c  ****                     &transfer_id,
 154:Src/uavcan.c  ****                     CANARD_TRANSFER_PRIORITY_LOW,
 155:Src/uavcan.c  ****                     buffer, 
 156:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_MESSAGE_SIZE);                         //some indication
 157:Src/uavcan.c  ****     
 158:Src/uavcan.c  **** }
 159:Src/uavcan.c  **** 
 160:Src/uavcan.c  **** void publishCanard(void)
 161:Src/uavcan.c  **** {  
 524              		.loc 1 161 0
 525              		.cfi_startproc
 526              		@ args = 0, pretend = 0, frame = 72
 527              		@ frame_needed = 0, uses_anonymous_args = 0
 528 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 529              	.LCFI9:
 530              		.cfi_def_cfa_offset 36
 531              		.cfi_offset 4, -36
 532              		.cfi_offset 5, -32
 533              		.cfi_offset 6, -28
 534              		.cfi_offset 7, -24
 535              		.cfi_offset 8, -20
 536              		.cfi_offset 9, -16
 537              		.cfi_offset 10, -12
 538              		.cfi_offset 11, -8
 539              		.cfi_offset 14, -4
 540 0004 99B0     		sub	sp, sp, #100
 541              	.LCFI10:
ARM GAS  /tmp/ccUNHGxP.s 			page 19


 542              		.cfi_def_cfa_offset 136
 162:Src/uavcan.c  ****     static uint32_t publish_time = 0;
 163:Src/uavcan.c  ****     static int step = 0;
 164:Src/uavcan.c  ****     if(HAL_GetTick() < publish_time + PUBLISHER_PERIOD_mS) {return;} // rate limiting
 543              		.loc 1 164 0
 544 0006 FFF7FEFF 		bl	HAL_GetTick
 545              	.LVL66:
 546 000a 3B4B     		ldr	r3, .L59+8
 547 000c 1B68     		ldr	r3, [r3]
 548 000e 1933     		adds	r3, r3, #25
 549 0010 9842     		cmp	r0, r3
 550 0012 02D2     		bcs	.L57
 551              	.L52:
 165:Src/uavcan.c  ****     publish_time = HAL_GetTick();
 166:Src/uavcan.c  ****   
 167:Src/uavcan.c  ****     uint8_t buffer[UAVCAN_PROTOCOL_DEBUG_KEYVALUE_MESSAGE_SIZE];
 168:Src/uavcan.c  ****     memset(buffer,0x00,UAVCAN_PROTOCOL_DEBUG_KEYVALUE_MESSAGE_SIZE);
 169:Src/uavcan.c  ****     step++;
 170:Src/uavcan.c  ****     if(step == 256) 
 171:Src/uavcan.c  ****     {
 172:Src/uavcan.c  ****         step = 0;
 173:Src/uavcan.c  ****     }
 174:Src/uavcan.c  ****   
 175:Src/uavcan.c  ****     float val = sine_wave[step];
 176:Src/uavcan.c  ****     static uint8_t transfer_id = 0;
 177:Src/uavcan.c  ****     canardEncodeScalar(buffer, 0, 32, &val);
 178:Src/uavcan.c  ****     memcpy(&buffer[4], "sin", 3);    
 179:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 180:Src/uavcan.c  ****                     UAVCAN_PROTOCOL_DEBUG_KEYVALUE_SIGNATURE,
 181:Src/uavcan.c  ****                     UAVCAN_PROTOCOL_DEBUG_KEYVALUE_ID,
 182:Src/uavcan.c  ****                     &transfer_id,
 183:Src/uavcan.c  ****                     CANARD_TRANSFER_PRIORITY_LOW,
 184:Src/uavcan.c  ****                     &buffer[0], 
 185:Src/uavcan.c  ****                     7);
 186:Src/uavcan.c  ****     memset(buffer,0x00,UAVCAN_PROTOCOL_DEBUG_KEYVALUE_MESSAGE_SIZE);
 187:Src/uavcan.c  ****   
 188:Src/uavcan.c  ****     val = step;
 189:Src/uavcan.c  ****     canardEncodeScalar(buffer, 0, 32, &val);
 190:Src/uavcan.c  ****     memcpy(&buffer[4], "stp", 3);  
 191:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 192:Src/uavcan.c  ****                     UAVCAN_PROTOCOL_DEBUG_KEYVALUE_SIGNATURE,
 193:Src/uavcan.c  ****                     UAVCAN_PROTOCOL_DEBUG_KEYVALUE_ID,
 194:Src/uavcan.c  ****                     &transfer_id,
 195:Src/uavcan.c  ****                     CANARD_TRANSFER_PRIORITY_LOW,
 196:Src/uavcan.c  ****                     &buffer[0], 
 197:Src/uavcan.c  ****                     7);
 198:Src/uavcan.c  **** }
 552              		.loc 1 198 0
 553 0014 19B0     		add	sp, sp, #100
 554              	.LCFI11:
 555              		.cfi_remember_state
 556              		.cfi_def_cfa_offset 36
 557              		@ sp needed
 558 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 559              	.L57:
 560              	.LCFI12:
 561              		.cfi_restore_state
ARM GAS  /tmp/ccUNHGxP.s 			page 20


 165:Src/uavcan.c  ****     publish_time = HAL_GetTick();
 562              		.loc 1 165 0
 563 001a FFF7FEFF 		bl	HAL_GetTick
 564              	.LVL67:
 565 001e 364B     		ldr	r3, .L59+8
 566 0020 1860     		str	r0, [r3]
 168:Src/uavcan.c  ****     step++;
 567              		.loc 1 168 0
 568 0022 3E22     		movs	r2, #62
 569 0024 0021     		movs	r1, #0
 570 0026 08A8     		add	r0, sp, #32
 571 0028 FFF7FEFF 		bl	memset
 572              	.LVL68:
 169:Src/uavcan.c  ****     if(step == 256) 
 573              		.loc 1 169 0
 574 002c 334A     		ldr	r2, .L59+12
 575 002e 1368     		ldr	r3, [r2]
 576 0030 0133     		adds	r3, r3, #1
 577 0032 1360     		str	r3, [r2]
 170:Src/uavcan.c  ****     {
 578              		.loc 1 170 0
 579 0034 B3F5807F 		cmp	r3, #256
 580 0038 55D0     		beq	.L58
 581              	.L54:
 175:Src/uavcan.c  ****     static uint8_t transfer_id = 0;
 582              		.loc 1 175 0
 583 003a DFF8C0B0 		ldr	fp, .L59+12
 584 003e DBF80030 		ldr	r3, [fp]
 585 0042 2F4A     		ldr	r2, .L59+16
 586 0044 D05C     		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 587 0046 FFF7FEFF 		bl	__aeabi_ui2f
 588              	.LVL69:
 589 004a 18AD     		add	r5, sp, #96
 590 004c 45F8440D 		str	r0, [r5, #-68]!	@ float
 177:Src/uavcan.c  ****     memcpy(&buffer[4], "sin", 3);    
 591              		.loc 1 177 0
 592 0050 08AC     		add	r4, sp, #32
 593 0052 2B46     		mov	r3, r5
 594 0054 2022     		movs	r2, #32
 595 0056 0021     		movs	r1, #0
 596 0058 2046     		mov	r0, r4
 597 005a FFF7FEFF 		bl	canardEncodeScalar
 598              	.LVL70:
 178:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 599              		.loc 1 178 0
 600 005e 294B     		ldr	r3, .L59+20
 601 0060 1B68     		ldr	r3, [r3]
 602 0062 ADF82430 		strh	r3, [sp, #36]	@ movhi
 603 0066 1B0C     		lsrs	r3, r3, #16
 604 0068 8DF82630 		strb	r3, [sp, #38]
 179:Src/uavcan.c  ****                     UAVCAN_PROTOCOL_DEBUG_KEYVALUE_SIGNATURE,
 605              		.loc 1 179 0
 606 006c 264E     		ldr	r6, .L59+24
 607 006e 4FF0070A 		mov	r10, #7
 608 0072 CDF810A0 		str	r10, [sp, #16]
 609 0076 0394     		str	r4, [sp, #12]
 610 0078 4FF01809 		mov	r9, #24
ARM GAS  /tmp/ccUNHGxP.s 			page 21


 611 007c CDF80890 		str	r9, [sp, #8]
 612 0080 DFF88C80 		ldr	r8, .L59+32
 613 0084 CDF80480 		str	r8, [sp, #4]
 614 0088 43F6F277 		movw	r7, #16370
 615 008c 0097     		str	r7, [sp]
 616 008e 18A3     		adr	r3, .L59
 617 0090 D3E90023 		ldrd	r2, [r3]
 618 0094 3046     		mov	r0, r6
 619 0096 FFF7FEFF 		bl	canardBroadcast
 620              	.LVL71:
 186:Src/uavcan.c  ****   
 621              		.loc 1 186 0
 622 009a 3E22     		movs	r2, #62
 623 009c 0021     		movs	r1, #0
 624 009e 2046     		mov	r0, r4
 625 00a0 FFF7FEFF 		bl	memset
 626              	.LVL72:
 188:Src/uavcan.c  ****     canardEncodeScalar(buffer, 0, 32, &val);
 627              		.loc 1 188 0
 628 00a4 DBF80000 		ldr	r0, [fp]
 629 00a8 FFF7FEFF 		bl	__aeabi_i2f
 630              	.LVL73:
 631 00ac 0790     		str	r0, [sp, #28]	@ float
 189:Src/uavcan.c  ****     memcpy(&buffer[4], "stp", 3);  
 632              		.loc 1 189 0
 633 00ae 2B46     		mov	r3, r5
 634 00b0 2022     		movs	r2, #32
 635 00b2 0021     		movs	r1, #0
 636 00b4 2046     		mov	r0, r4
 637 00b6 FFF7FEFF 		bl	canardEncodeScalar
 638              	.LVL74:
 190:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 639              		.loc 1 190 0
 640 00ba 144B     		ldr	r3, .L59+28
 641 00bc 1B68     		ldr	r3, [r3]
 642 00be ADF82430 		strh	r3, [sp, #36]	@ movhi
 643 00c2 1B0C     		lsrs	r3, r3, #16
 644 00c4 8DF82630 		strb	r3, [sp, #38]
 191:Src/uavcan.c  ****                     UAVCAN_PROTOCOL_DEBUG_KEYVALUE_SIGNATURE,
 645              		.loc 1 191 0
 646 00c8 CDF810A0 		str	r10, [sp, #16]
 647 00cc 0394     		str	r4, [sp, #12]
 648 00ce CDF80890 		str	r9, [sp, #8]
 649 00d2 CDF80480 		str	r8, [sp, #4]
 650 00d6 0097     		str	r7, [sp]
 651 00d8 05A3     		adr	r3, .L59
 652 00da D3E90023 		ldrd	r2, [r3]
 653 00de 3046     		mov	r0, r6
 654 00e0 FFF7FEFF 		bl	canardBroadcast
 655              	.LVL75:
 656 00e4 96E7     		b	.L52
 657              	.L58:
 172:Src/uavcan.c  ****     }
 658              		.loc 1 172 0
 659 00e6 0022     		movs	r2, #0
 660 00e8 044B     		ldr	r3, .L59+12
 661 00ea 1A60     		str	r2, [r3]
ARM GAS  /tmp/ccUNHGxP.s 			page 22


 662 00ec A5E7     		b	.L54
 663              	.L60:
 664 00ee 00BF     		.align	3
 665              	.L59:
 666 00f0 E08AC9E0 		.word	-523662624
 667 00f4 D6252FE0 		.word	-533781034
 668 00f8 00000000 		.word	.LANCHOR3
 669 00fc 00000000 		.word	.LANCHOR4
 670 0100 00000000 		.word	.LANCHOR5
 671 0104 00000000 		.word	.LC3
 672 0108 00000000 		.word	.LANCHOR2
 673 010c 04000000 		.word	.LC4
 674 0110 00000000 		.word	.LANCHOR6
 675              		.cfi_endproc
 676              	.LFE72:
 678              		.section	.text.makeNodeStatusMessage,"ax",%progbits
 679              		.align	1
 680              		.global	makeNodeStatusMessage
 681              		.syntax unified
 682              		.thumb
 683              		.thumb_func
 684              		.fpu softvfp
 686              	makeNodeStatusMessage:
 687              	.LFB73:
 199:Src/uavcan.c  **** 
 200:Src/uavcan.c  **** void makeNodeStatusMessage(uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE])
 201:Src/uavcan.c  **** {
 688              		.loc 1 201 0
 689              		.cfi_startproc
 690              		@ args = 0, pretend = 0, frame = 8
 691              		@ frame_needed = 0, uses_anonymous_args = 0
 692              	.LVL76:
 693 0000 30B5     		push	{r4, r5, lr}
 694              	.LCFI13:
 695              		.cfi_def_cfa_offset 12
 696              		.cfi_offset 4, -12
 697              		.cfi_offset 5, -8
 698              		.cfi_offset 14, -4
 699 0002 83B0     		sub	sp, sp, #12
 700              	.LCFI14:
 701              		.cfi_def_cfa_offset 24
 702 0004 0446     		mov	r4, r0
 202:Src/uavcan.c  ****     uint8_t node_health = UAVCAN_NODE_HEALTH_OK;
 703              		.loc 1 202 0
 704 0006 0025     		movs	r5, #0
 705 0008 8DF80750 		strb	r5, [sp, #7]
 203:Src/uavcan.c  ****     uint8_t node_mode   = UAVCAN_NODE_MODE_OPERATIONAL;
 706              		.loc 1 203 0
 707 000c 8DF80650 		strb	r5, [sp, #6]
 204:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_NODE_STATUS_MESSAGE_SIZE);
 708              		.loc 1 204 0
 709 0010 0560     		str	r5, [r0]	@ unaligned
 710 0012 C0F80350 		str	r5, [r0, #3]	@ unaligned
 205:Src/uavcan.c  ****     uint32_t uptime_sec = (HAL_GetTick() / 1000);
 711              		.loc 1 205 0
 712 0016 FFF7FEFF 		bl	HAL_GetTick
 713              	.LVL77:
ARM GAS  /tmp/ccUNHGxP.s 			page 23


 714 001a 0E4B     		ldr	r3, .L63
 715 001c A3FB0030 		umull	r3, r0, r3, r0
 716 0020 8009     		lsrs	r0, r0, #6
 717 0022 02AB     		add	r3, sp, #8
 718 0024 43F8080D 		str	r0, [r3, #-8]!
 206:Src/uavcan.c  ****     canardEncodeScalar(buffer,  0, 32, &uptime_sec);
 719              		.loc 1 206 0
 720 0028 2022     		movs	r2, #32
 721 002a 2946     		mov	r1, r5
 722 002c 2046     		mov	r0, r4
 723 002e FFF7FEFF 		bl	canardEncodeScalar
 724              	.LVL78:
 207:Src/uavcan.c  ****     canardEncodeScalar(buffer, 32,  2, &node_health);
 725              		.loc 1 207 0
 726 0032 0DF10703 		add	r3, sp, #7
 727 0036 0222     		movs	r2, #2
 728 0038 2021     		movs	r1, #32
 729 003a 2046     		mov	r0, r4
 730 003c FFF7FEFF 		bl	canardEncodeScalar
 731              	.LVL79:
 208:Src/uavcan.c  ****     canardEncodeScalar(buffer, 34,  3, &node_mode);
 732              		.loc 1 208 0
 733 0040 0DF10603 		add	r3, sp, #6
 734 0044 0322     		movs	r2, #3
 735 0046 2221     		movs	r1, #34
 736 0048 2046     		mov	r0, r4
 737 004a FFF7FEFF 		bl	canardEncodeScalar
 738              	.LVL80:
 209:Src/uavcan.c  **** }
 739              		.loc 1 209 0
 740 004e 03B0     		add	sp, sp, #12
 741              	.LCFI15:
 742              		.cfi_def_cfa_offset 12
 743              		@ sp needed
 744 0050 30BD     		pop	{r4, r5, pc}
 745              	.LVL81:
 746              	.L64:
 747 0052 00BF     		.align	2
 748              	.L63:
 749 0054 D34D6210 		.word	274877907
 750              		.cfi_endproc
 751              	.LFE73:
 753              		.section	.text.spinCanard,"ax",%progbits
 754              		.align	1
 755              		.global	spinCanard
 756              		.syntax unified
 757              		.thumb
 758              		.thumb_func
 759              		.fpu softvfp
 761              	spinCanard:
 762              	.LFB71:
 141:Src/uavcan.c  ****     static uint32_t spin_time = 0;
 763              		.loc 1 141 0
 764              		.cfi_startproc
 765              		@ args = 0, pretend = 0, frame = 8
 766              		@ frame_needed = 0, uses_anonymous_args = 0
 767 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/ccUNHGxP.s 			page 24


 768              	.LCFI16:
 769              		.cfi_def_cfa_offset 8
 770              		.cfi_offset 4, -8
 771              		.cfi_offset 14, -4
 772 0002 88B0     		sub	sp, sp, #32
 773              	.LCFI17:
 774              		.cfi_def_cfa_offset 40
 143:Src/uavcan.c  ****     spin_time = HAL_GetTick();
 775              		.loc 1 143 0
 776 0004 FFF7FEFF 		bl	HAL_GetTick
 777              	.LVL82:
 778 0008 154B     		ldr	r3, .L70+8
 779 000a 1B68     		ldr	r3, [r3]
 780 000c 03F5FA73 		add	r3, r3, #500
 781 0010 9842     		cmp	r0, r3
 782 0012 01D2     		bcs	.L69
 783              	.L65:
 158:Src/uavcan.c  **** 
 784              		.loc 1 158 0
 785 0014 08B0     		add	sp, sp, #32
 786              	.LCFI18:
 787              		.cfi_remember_state
 788              		.cfi_def_cfa_offset 8
 789              		@ sp needed
 790 0016 10BD     		pop	{r4, pc}
 791              	.L69:
 792              	.LCFI19:
 793              		.cfi_restore_state
 144:Src/uavcan.c  ****     HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_12);   
 794              		.loc 1 144 0
 795 0018 FFF7FEFF 		bl	HAL_GetTick
 796              	.LVL83:
 797 001c 104B     		ldr	r3, .L70+8
 798 001e 1860     		str	r0, [r3]
 145:Src/uavcan.c  ****     
 799              		.loc 1 145 0
 800 0020 4FF48051 		mov	r1, #4096
 801 0024 0F48     		ldr	r0, .L70+12
 802 0026 FFF7FEFF 		bl	HAL_GPIO_TogglePin
 803              	.LVL84:
 149:Src/uavcan.c  ****     canardBroadcast(&g_canard, 
 804              		.loc 1 149 0
 805 002a 06AC     		add	r4, sp, #24
 806 002c 2046     		mov	r0, r4
 807 002e FFF7FEFF 		bl	makeNodeStatusMessage
 808              	.LVL85:
 150:Src/uavcan.c  ****                     UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
 809              		.loc 1 150 0
 810 0032 0723     		movs	r3, #7
 811 0034 0493     		str	r3, [sp, #16]
 812 0036 0394     		str	r4, [sp, #12]
 813 0038 1823     		movs	r3, #24
 814 003a 0293     		str	r3, [sp, #8]
 815 003c 0A4B     		ldr	r3, .L70+16
 816 003e 0193     		str	r3, [sp, #4]
 817 0040 40F25513 		movw	r3, #341
 818 0044 0093     		str	r3, [sp]
ARM GAS  /tmp/ccUNHGxP.s 			page 25


 819 0046 04A3     		adr	r3, .L70
 820 0048 D3E90023 		ldrd	r2, [r3]
 821 004c 0748     		ldr	r0, .L70+20
 822 004e FFF7FEFF 		bl	canardBroadcast
 823              	.LVL86:
 824 0052 DFE7     		b	.L65
 825              	.L71:
 826 0054 AFF30080 		.align	3
 827              	.L70:
 828 0058 F1C6A7C1 		.word	-1045969167
 829 005c D068080F 		.word	252209360
 830 0060 00000000 		.word	.LANCHOR7
 831 0064 000C0140 		.word	1073810432
 832 0068 00000000 		.word	.LANCHOR8
 833 006c 00000000 		.word	.LANCHOR2
 834              		.cfi_endproc
 835              	.LFE71:
 837              		.section	.text.readUniqueID,"ax",%progbits
 838              		.align	1
 839              		.global	readUniqueID
 840              		.syntax unified
 841              		.thumb
 842              		.thumb_func
 843              		.fpu softvfp
 845              	readUniqueID:
 846              	.LFB75:
 210:Src/uavcan.c  **** 
 211:Src/uavcan.c  **** uint16_t makeNodeInfoMessage(uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE])
 212:Src/uavcan.c  **** {
 213:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 214:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);
 215:Src/uavcan.c  ****    
 216:Src/uavcan.c  ****     buffer[7] = APP_VERSION_MAJOR;
 217:Src/uavcan.c  ****     buffer[8] = APP_VERSION_MINOR;
 218:Src/uavcan.c  ****     buffer[9] = 1;                          // Optional field flags, VCS commit is set
 219:Src/uavcan.c  ****     uint32_t u32 = GIT_HASH;
 220:Src/uavcan.c  ****     canardEncodeScalar(buffer, 80, 32, &u32); 
 221:Src/uavcan.c  ****     
 222:Src/uavcan.c  ****     readUniqueID(&buffer[24]);
 223:Src/uavcan.c  ****     const size_t name_len = strlen(APP_NODE_NAME);
 224:Src/uavcan.c  ****     memcpy(&buffer[41], APP_NODE_NAME, name_len);
 225:Src/uavcan.c  ****     return 41 + name_len ;
 226:Src/uavcan.c  **** }
 227:Src/uavcan.c  **** 
 228:Src/uavcan.c  **** void readUniqueID(uint8_t* out_uid)
 229:Src/uavcan.c  **** {
 847              		.loc 1 229 0
 848              		.cfi_startproc
 849              		@ args = 0, pretend = 0, frame = 0
 850              		@ frame_needed = 0, uses_anonymous_args = 0
 851              		@ link register save eliminated.
 852              	.LVL87:
 853              	.LBB19:
 230:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 854              		.loc 1 230 0
 855 0000 0023     		movs	r3, #0
 856 0002 02E0     		b	.L73
ARM GAS  /tmp/ccUNHGxP.s 			page 26


 857              	.LVL88:
 858              	.L74:
 231:Src/uavcan.c  ****     {
 232:Src/uavcan.c  ****         out_uid[i] = i;
 859              		.loc 1 232 0 discriminator 3
 860 0004 C354     		strb	r3, [r0, r3]
 230:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 861              		.loc 1 230 0 discriminator 3
 862 0006 0133     		adds	r3, r3, #1
 863              	.LVL89:
 864 0008 DBB2     		uxtb	r3, r3
 865              	.LVL90:
 866              	.L73:
 230:Src/uavcan.c  ****     for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
 867              		.loc 1 230 0 is_stmt 0 discriminator 1
 868 000a 0F2B     		cmp	r3, #15
 869 000c FAD9     		bls	.L74
 870              	.LBE19:
 233:Src/uavcan.c  ****     }
 234:Src/uavcan.c  **** }
 871              		.loc 1 234 0 is_stmt 1
 872 000e 7047     		bx	lr
 873              		.cfi_endproc
 874              	.LFE75:
 876              		.section	.text.makeNodeInfoMessage,"ax",%progbits
 877              		.align	1
 878              		.global	makeNodeInfoMessage
 879              		.syntax unified
 880              		.thumb
 881              		.thumb_func
 882              		.fpu softvfp
 884              	makeNodeInfoMessage:
 885              	.LFB74:
 212:Src/uavcan.c  ****     memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
 886              		.loc 1 212 0
 887              		.cfi_startproc
 888              		@ args = 0, pretend = 0, frame = 8
 889              		@ frame_needed = 0, uses_anonymous_args = 0
 890              	.LVL91:
 891 0000 30B5     		push	{r4, r5, lr}
 892              	.LCFI20:
 893              		.cfi_def_cfa_offset 12
 894              		.cfi_offset 4, -12
 895              		.cfi_offset 5, -8
 896              		.cfi_offset 14, -4
 897 0002 83B0     		sub	sp, sp, #12
 898              	.LCFI21:
 899              		.cfi_def_cfa_offset 24
 900 0004 0446     		mov	r4, r0
 213:Src/uavcan.c  ****     makeNodeStatusMessage(buffer);
 901              		.loc 1 213 0
 902 0006 40F27912 		movw	r2, #377
 903 000a 0021     		movs	r1, #0
 904 000c FFF7FEFF 		bl	memset
 905              	.LVL92:
 214:Src/uavcan.c  ****    
 906              		.loc 1 214 0
ARM GAS  /tmp/ccUNHGxP.s 			page 27


 907 0010 2046     		mov	r0, r4
 908 0012 FFF7FEFF 		bl	makeNodeStatusMessage
 909              	.LVL93:
 216:Src/uavcan.c  ****     buffer[8] = APP_VERSION_MINOR;
 910              		.loc 1 216 0
 911 0016 6323     		movs	r3, #99
 912 0018 E371     		strb	r3, [r4, #7]
 217:Src/uavcan.c  ****     buffer[9] = 1;                          // Optional field flags, VCS commit is set
 913              		.loc 1 217 0
 914 001a 2372     		strb	r3, [r4, #8]
 218:Src/uavcan.c  ****     uint32_t u32 = GIT_HASH;
 915              		.loc 1 218 0
 916 001c 0123     		movs	r3, #1
 917 001e 6372     		strb	r3, [r4, #9]
 219:Src/uavcan.c  ****     canardEncodeScalar(buffer, 80, 32, &u32); 
 918              		.loc 1 219 0
 919 0020 02AB     		add	r3, sp, #8
 920 0022 0E4A     		ldr	r2, .L77
 921 0024 43F8042D 		str	r2, [r3, #-4]!
 220:Src/uavcan.c  ****     
 922              		.loc 1 220 0
 923 0028 2022     		movs	r2, #32
 924 002a 5021     		movs	r1, #80
 925 002c 2046     		mov	r0, r4
 926 002e FFF7FEFF 		bl	canardEncodeScalar
 927              	.LVL94:
 222:Src/uavcan.c  ****     const size_t name_len = strlen(APP_NODE_NAME);
 928              		.loc 1 222 0
 929 0032 04F11800 		add	r0, r4, #24
 930 0036 FFF7FEFF 		bl	readUniqueID
 931              	.LVL95:
 224:Src/uavcan.c  ****     return 41 + name_len ;
 932              		.loc 1 224 0
 933 003a 094B     		ldr	r3, .L77+4
 934 003c 07CB     		ldmia	r3!, {r0, r1, r2}
 935 003e C4F82900 		str	r0, [r4, #41]	@ unaligned
 936 0042 C4F82D10 		str	r1, [r4, #45]	@ unaligned
 937 0046 C4F83120 		str	r2, [r4, #49]	@ unaligned
 938 004a 1A88     		ldrh	r2, [r3]	@ unaligned
 939 004c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 940 004e A4F83520 		strh	r2, [r4, #53]	@ unaligned
 941 0052 84F83730 		strb	r3, [r4, #55]
 226:Src/uavcan.c  **** 
 942              		.loc 1 226 0
 943 0056 3820     		movs	r0, #56
 944 0058 03B0     		add	sp, sp, #12
 945              	.LCFI22:
 946              		.cfi_def_cfa_offset 12
 947              		@ sp needed
 948 005a 30BD     		pop	{r4, r5, pc}
 949              	.LVL96:
 950              	.L78:
 951              		.align	2
 952              	.L77:
 953 005c FE0FDCBA 		.word	-1159983106
 954 0060 00000000 		.word	.LC5
 955              		.cfi_endproc
ARM GAS  /tmp/ccUNHGxP.s 			page 28


 956              	.LFE74:
 958              		.section	.text.getNodeInfoHandleCanard,"ax",%progbits
 959              		.align	1
 960              		.global	getNodeInfoHandleCanard
 961              		.syntax unified
 962              		.thumb
 963              		.thumb_func
 964              		.fpu softvfp
 966              	getNodeInfoHandleCanard:
 967              	.LFB67:
  69:Src/uavcan.c  ****         uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE];
 968              		.loc 1 69 0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 384
 971              		@ frame_needed = 0, uses_anonymous_args = 0
 972              	.LVL97:
 973 0000 30B5     		push	{r4, r5, lr}
 974              	.LCFI23:
 975              		.cfi_def_cfa_offset 12
 976              		.cfi_offset 4, -12
 977              		.cfi_offset 5, -8
 978              		.cfi_offset 14, -4
 979 0002 E7B0     		sub	sp, sp, #412
 980              	.LCFI24:
 981              		.cfi_def_cfa_offset 424
 982 0004 0446     		mov	r4, r0
  71:Src/uavcan.c  ****         uint16_t len = makeNodeInfoMessage(buffer);
 983              		.loc 1 71 0
 984 0006 07AD     		add	r5, sp, #28
 985 0008 40F27912 		movw	r2, #377
 986 000c 0021     		movs	r1, #0
 987 000e 2846     		mov	r0, r5
 988              	.LVL98:
 989 0010 FFF7FEFF 		bl	memset
 990              	.LVL99:
  72:Src/uavcan.c  ****         int result = canardRequestOrRespond(&g_canard,
 991              		.loc 1 72 0
 992 0014 2846     		mov	r0, r5
 993 0016 FFF7FEFF 		bl	makeNodeInfoMessage
 994              	.LVL100:
  73:Src/uavcan.c  ****                                             transfer->source_node_id,
 995              		.loc 1 73 0
 996 001a E17E     		ldrb	r1, [r4, #27]	@ zero_extendqisi2
 997 001c 0590     		str	r0, [sp, #20]
 998 001e 0495     		str	r5, [sp, #16]
 999 0020 0023     		movs	r3, #0
 1000 0022 0393     		str	r3, [sp, #12]
 1001 0024 A37E     		ldrb	r3, [r4, #26]	@ zero_extendqisi2
 1002 0026 0293     		str	r3, [sp, #8]
 1003 0028 1934     		adds	r4, r4, #25
 1004              	.LVL101:
 1005 002a 0194     		str	r4, [sp, #4]
 1006 002c 0123     		movs	r3, #1
 1007 002e 0093     		str	r3, [sp]
 1008 0030 04A3     		adr	r3, .L81+4
 1009 0032 D3E90023 		ldrd	r2, [r3]
 1010 0036 0248     		ldr	r0, .L81
ARM GAS  /tmp/ccUNHGxP.s 			page 29


 1011              	.LVL102:
 1012 0038 FFF7FEFF 		bl	canardRequestOrRespond
 1013              	.LVL103:
  82:Src/uavcan.c  **** 
 1014              		.loc 1 82 0
 1015 003c 67B0     		add	sp, sp, #412
 1016              	.LCFI25:
 1017              		.cfi_def_cfa_offset 12
 1018              		@ sp needed
 1019 003e 30BD     		pop	{r4, r5, pc}
 1020              	.LVL104:
 1021              	.L82:
 1022              		.align	3
 1023              	.L81:
 1024 0040 00000000 		.word	.LANCHOR2
 1025 0044 9E6AC421 		.word	566520478
 1026 0048 818A46EE 		.word	-297366911
 1027              		.cfi_endproc
 1028              	.LFE67:
 1030              		.section	.text.rawcmdHandleCanard,"ax",%progbits
 1031              		.align	1
 1032              		.global	rawcmdHandleCanard
 1033              		.syntax unified
 1034              		.thumb
 1035              		.thumb_func
 1036              		.fpu softvfp
 1038              	rawcmdHandleCanard:
 1039              	.LFB76:
 235:Src/uavcan.c  **** 
 236:Src/uavcan.c  **** 
 237:Src/uavcan.c  **** void rawcmdHandleCanard(CanardRxTransfer* transfer)
 238:Src/uavcan.c  **** {
 1040              		.loc 1 238 0
 1041              		.cfi_startproc
 1042              		@ args = 0, pretend = 0, frame = 0
 1043              		@ frame_needed = 0, uses_anonymous_args = 0
 1044              	.LVL105:
 1045 0000 70B5     		push	{r4, r5, r6, lr}
 1046              	.LCFI26:
 1047              		.cfi_def_cfa_offset 16
 1048              		.cfi_offset 4, -16
 1049              		.cfi_offset 5, -12
 1050              		.cfi_offset 6, -8
 1051              		.cfi_offset 14, -4
 1052 0002 82B0     		sub	sp, sp, #8
 1053              	.LCFI27:
 1054              		.cfi_def_cfa_offset 24
 1055 0004 0646     		mov	r6, r0
 1056              	.LVL106:
 1057              	.LBB20:
 239:Src/uavcan.c  ****     
 240:Src/uavcan.c  ****     int offset = 0;
 241:Src/uavcan.c  ****     for (int i = 0; i<6; i++)
 1058              		.loc 1 241 0
 1059 0006 0024     		movs	r4, #0
 1060              	.LBE20:
 240:Src/uavcan.c  ****     for (int i = 0; i<6; i++)
ARM GAS  /tmp/ccUNHGxP.s 			page 30


 1061              		.loc 1 240 0
 1062 0008 2546     		mov	r5, r4
 1063              	.LVL107:
 1064              	.L84:
 1065              	.LBB21:
 1066              		.loc 1 241 0 discriminator 1
 1067 000a 052C     		cmp	r4, #5
 1068 000c 0EDC     		bgt	.L83
 242:Src/uavcan.c  ****     {
 243:Src/uavcan.c  ****         if (canardDecodeScalar(transfer, offset, 14, true, &rc_pwm[i])<14) { break; }
 1069              		.loc 1 243 0
 1070 000e 084B     		ldr	r3, .L88
 1071 0010 03EB4403 		add	r3, r3, r4, lsl #1
 1072 0014 0093     		str	r3, [sp]
 1073 0016 0123     		movs	r3, #1
 1074 0018 0E22     		movs	r2, #14
 1075 001a 2946     		mov	r1, r5
 1076 001c 3046     		mov	r0, r6
 1077 001e FFF7FEFF 		bl	canardDecodeScalar
 1078              	.LVL108:
 1079 0022 0D28     		cmp	r0, #13
 1080 0024 02DD     		ble	.L83
 244:Src/uavcan.c  ****         offset += 14;
 1081              		.loc 1 244 0 discriminator 2
 1082 0026 0E35     		adds	r5, r5, #14
 1083              	.LVL109:
 241:Src/uavcan.c  ****     {
 1084              		.loc 1 241 0 discriminator 2
 1085 0028 0134     		adds	r4, r4, #1
 1086              	.LVL110:
 1087 002a EEE7     		b	.L84
 1088              	.L83:
 1089              	.LBE21:
 245:Src/uavcan.c  ****     }
 246:Src/uavcan.c  ****    // rcpwmUpdate(ar);
 247:Src/uavcan.c  **** }
 1090              		.loc 1 247 0
 1091 002c 02B0     		add	sp, sp, #8
 1092              	.LCFI28:
 1093              		.cfi_def_cfa_offset 16
 1094              		@ sp needed
 1095 002e 70BD     		pop	{r4, r5, r6, pc}
 1096              	.LVL111:
 1097              	.L89:
 1098              		.align	2
 1099              	.L88:
 1100 0030 00000000 		.word	.LANCHOR9
 1101              		.cfi_endproc
 1102              	.LFE76:
 1104              		.section	.text.showRcpwmonUart,"ax",%progbits
 1105              		.align	1
 1106              		.global	showRcpwmonUart
 1107              		.syntax unified
 1108              		.thumb
 1109              		.thumb_func
 1110              		.fpu softvfp
 1112              	showRcpwmonUart:
ARM GAS  /tmp/ccUNHGxP.s 			page 31


 1113              	.LFB77:
 248:Src/uavcan.c  **** 
 249:Src/uavcan.c  **** void showRcpwmonUart()
 250:Src/uavcan.c  **** {
 1114              		.loc 1 250 0
 1115              		.cfi_startproc
 1116              		@ args = 0, pretend = 0, frame = 8
 1117              		@ frame_needed = 0, uses_anonymous_args = 0
 1118 0000 10B5     		push	{r4, lr}
 1119              	.LCFI29:
 1120              		.cfi_def_cfa_offset 8
 1121              		.cfi_offset 4, -8
 1122              		.cfi_offset 14, -4
 1123 0002 82B0     		sub	sp, sp, #8
 1124              	.LCFI30:
 1125              		.cfi_def_cfa_offset 16
 251:Src/uavcan.c  ****     char str[5];
 252:Src/uavcan.c  ****     itoa(rc_pwm[0],str,10);
 1126              		.loc 1 252 0
 1127 0004 0A22     		movs	r2, #10
 1128 0006 6946     		mov	r1, sp
 1129 0008 0A4B     		ldr	r3, .L92
 1130 000a 1888     		ldrh	r0, [r3]
 1131 000c FFF7FEFF 		bl	itoa
 1132              	.LVL112:
 253:Src/uavcan.c  ****     HAL_UART_Transmit(&huart1,str,5,0xffff);
 1133              		.loc 1 253 0
 1134 0010 094C     		ldr	r4, .L92+4
 1135 0012 4FF6FF73 		movw	r3, #65535
 1136 0016 0522     		movs	r2, #5
 1137 0018 6946     		mov	r1, sp
 1138 001a 2046     		mov	r0, r4
 1139 001c FFF7FEFF 		bl	HAL_UART_Transmit
 1140              	.LVL113:
 254:Src/uavcan.c  ****     HAL_UART_Transmit(&huart1,"\n",2,0xffff);
 1141              		.loc 1 254 0
 1142 0020 4FF6FF73 		movw	r3, #65535
 1143 0024 0222     		movs	r2, #2
 1144 0026 0549     		ldr	r1, .L92+8
 1145 0028 2046     		mov	r0, r4
 1146 002a FFF7FEFF 		bl	HAL_UART_Transmit
 1147              	.LVL114:
 255:Src/uavcan.c  **** }
 1148              		.loc 1 255 0
 1149 002e 02B0     		add	sp, sp, #8
 1150              	.LCFI31:
 1151              		.cfi_def_cfa_offset 8
 1152              		@ sp needed
 1153 0030 10BD     		pop	{r4, pc}
 1154              	.L93:
 1155 0032 00BF     		.align	2
 1156              	.L92:
 1157 0034 00000000 		.word	.LANCHOR9
 1158 0038 00000000 		.word	huart1
 1159 003c 00000000 		.word	.LC6
 1160              		.cfi_endproc
 1161              	.LFE77:
ARM GAS  /tmp/ccUNHGxP.s 			page 32


 1163              		.section	.text.encodeParamCanard,"ax",%progbits
 1164              		.align	1
 1165              		.global	encodeParamCanard
 1166              		.syntax unified
 1167              		.thumb
 1168              		.thumb_func
 1169              		.fpu softvfp
 1171              	encodeParamCanard:
 1172              	.LFB80:
 256:Src/uavcan.c  **** 
 257:Src/uavcan.c  **** 
 258:Src/uavcan.c  **** 
 259:Src/uavcan.c  **** 
 260:Src/uavcan.c  **** 
 261:Src/uavcan.c  **** param_t parameters[] =
 262:Src/uavcan.c  **** {
 263:Src/uavcan.c  ****     {"param0", 0, 10,20, 15},
 264:Src/uavcan.c  ****     {"param1", 1, 0, 100, 25},
 265:Src/uavcan.c  ****     {"param2", 2, 2, 8,  3 },
 266:Src/uavcan.c  **** };
 267:Src/uavcan.c  **** 
 268:Src/uavcan.c  **** inline param_t * getParamByIndex(uint16_t index)
 269:Src/uavcan.c  **** {
 270:Src/uavcan.c  ****   if(index >= ARRAY_SIZE(parameters)) 
 271:Src/uavcan.c  ****   {
 272:Src/uavcan.c  ****     return NULL;
 273:Src/uavcan.c  ****   }
 274:Src/uavcan.c  **** 
 275:Src/uavcan.c  ****   return &parameters[index];
 276:Src/uavcan.c  **** }
 277:Src/uavcan.c  **** 
 278:Src/uavcan.c  **** inline param_t * getParamByName(uint8_t * name)
 279:Src/uavcan.c  **** {
 280:Src/uavcan.c  ****   for(uint16_t i = 0; i < ARRAY_SIZE(parameters); i++)
 281:Src/uavcan.c  ****   {
 282:Src/uavcan.c  ****     if(strncmp((char const*)name, (char const*)parameters[i].name,strlen((char const*)parameters[i]
 283:Src/uavcan.c  ****     {
 284:Src/uavcan.c  ****       return &parameters[i];
 285:Src/uavcan.c  ****     }
 286:Src/uavcan.c  ****   }      
 287:Src/uavcan.c  ****   return NULL;
 288:Src/uavcan.c  **** }
 289:Src/uavcan.c  **** 
 290:Src/uavcan.c  **** uint16_t encodeParamCanard(param_t * p, uint8_t * buffer)
 291:Src/uavcan.c  **** {
 1173              		.loc 1 291 0
 1174              		.cfi_startproc
 1175              		@ args = 0, pretend = 0, frame = 8
 1176              		@ frame_needed = 0, uses_anonymous_args = 0
 1177              	.LVL115:
 1178 0000 70B5     		push	{r4, r5, r6, lr}
 1179              	.LCFI32:
 1180              		.cfi_def_cfa_offset 16
 1181              		.cfi_offset 4, -16
 1182              		.cfi_offset 5, -12
 1183              		.cfi_offset 6, -8
 1184              		.cfi_offset 14, -4
ARM GAS  /tmp/ccUNHGxP.s 			page 33


 1185 0002 82B0     		sub	sp, sp, #8
 1186              	.LCFI33:
 1187              		.cfi_def_cfa_offset 24
 1188 0004 0C46     		mov	r4, r1
 292:Src/uavcan.c  ****     uint8_t n     = 0;
 1189              		.loc 1 292 0
 1190 0006 0023     		movs	r3, #0
 1191 0008 8DF80730 		strb	r3, [sp, #7]
 1192              	.LVL116:
 293:Src/uavcan.c  ****     int offset    = 0;
 294:Src/uavcan.c  ****     uint8_t tag   = 1;
 1193              		.loc 1 294 0
 1194 000c 0123     		movs	r3, #1
 1195 000e 8DF80630 		strb	r3, [sp, #6]
 295:Src/uavcan.c  ****     if(p==NULL)
 1196              		.loc 1 295 0
 1197 0012 0028     		cmp	r0, #0
 1198 0014 65D0     		beq	.L98
 1199 0016 0546     		mov	r5, r0
 296:Src/uavcan.c  ****     {   
 297:Src/uavcan.c  ****         tag = 0;
 298:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 5, &n);
 299:Src/uavcan.c  ****         offset += 5;
 300:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset,3, &tag);
 301:Src/uavcan.c  ****         offset += 3;
 302:Src/uavcan.c  ****         
 303:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 6, &n);
 304:Src/uavcan.c  ****         offset += 6;
 305:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset,2, &tag);
 306:Src/uavcan.c  ****         offset += 2;
 307:Src/uavcan.c  ****         
 308:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 6, &n);
 309:Src/uavcan.c  ****         offset += 6;
 310:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 2, &tag);
 311:Src/uavcan.c  ****         offset += 2;
 312:Src/uavcan.c  ****         buffer[offset / 8] = 0;
 313:Src/uavcan.c  ****         return ( offset / 8 + 1 );
 314:Src/uavcan.c  ****     }
 315:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 5,&n);
 1200              		.loc 1 315 0
 1201 0018 0DF10703 		add	r3, sp, #7
 1202 001c 0522     		movs	r2, #5
 1203 001e 0021     		movs	r1, #0
 1204              	.LVL117:
 1205 0020 2046     		mov	r0, r4
 1206              	.LVL118:
 1207 0022 FFF7FEFF 		bl	canardEncodeScalar
 1208              	.LVL119:
 316:Src/uavcan.c  ****     offset += 5;
 317:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 3, &tag);
 1209              		.loc 1 317 0
 1210 0026 0DF10603 		add	r3, sp, #6
 1211 002a 0322     		movs	r2, #3
 1212 002c 0521     		movs	r1, #5
 1213 002e 2046     		mov	r0, r4
 1214 0030 FFF7FEFF 		bl	canardEncodeScalar
 1215              	.LVL120:
ARM GAS  /tmp/ccUNHGxP.s 			page 34


 318:Src/uavcan.c  ****     offset += 3;
 319:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 64, &p->val);
 1216              		.loc 1 319 0
 1217 0034 05F10803 		add	r3, r5, #8
 1218 0038 4022     		movs	r2, #64
 1219 003a 0821     		movs	r1, #8
 1220 003c 2046     		mov	r0, r4
 1221 003e FFF7FEFF 		bl	canardEncodeScalar
 1222              	.LVL121:
 320:Src/uavcan.c  ****     offset += 64;
 321:Src/uavcan.c  ****     
 322:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 5, &n);
 1223              		.loc 1 322 0
 1224 0042 0DF10703 		add	r3, sp, #7
 1225 0046 0522     		movs	r2, #5
 1226 0048 4821     		movs	r1, #72
 1227 004a 2046     		mov	r0, r4
 1228 004c FFF7FEFF 		bl	canardEncodeScalar
 1229              	.LVL122:
 323:Src/uavcan.c  ****     offset += 5;
 324:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 3, &tag);
 1230              		.loc 1 324 0
 1231 0050 0DF10603 		add	r3, sp, #6
 1232 0054 0322     		movs	r2, #3
 1233 0056 4D21     		movs	r1, #77
 1234 0058 2046     		mov	r0, r4
 1235 005a FFF7FEFF 		bl	canardEncodeScalar
 1236              	.LVL123:
 325:Src/uavcan.c  ****     offset += 3;
 326:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 64, &p->defval);
 1237              		.loc 1 326 0
 1238 005e 05F12003 		add	r3, r5, #32
 1239 0062 4022     		movs	r2, #64
 1240 0064 5021     		movs	r1, #80
 1241 0066 2046     		mov	r0, r4
 1242 0068 FFF7FEFF 		bl	canardEncodeScalar
 1243              	.LVL124:
 327:Src/uavcan.c  ****     offset += 64;
 328:Src/uavcan.c  ****     
 329:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 6, &n);
 1244              		.loc 1 329 0
 1245 006c 0DF10703 		add	r3, sp, #7
 1246 0070 0622     		movs	r2, #6
 1247 0072 9021     		movs	r1, #144
 1248 0074 2046     		mov	r0, r4
 1249 0076 FFF7FEFF 		bl	canardEncodeScalar
 1250              	.LVL125:
 330:Src/uavcan.c  ****     offset += 6;
 331:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 2, &tag);
 1251              		.loc 1 331 0
 1252 007a 0DF10603 		add	r3, sp, #6
 1253 007e 0222     		movs	r2, #2
 1254 0080 9621     		movs	r1, #150
 1255 0082 2046     		mov	r0, r4
 1256 0084 FFF7FEFF 		bl	canardEncodeScalar
 1257              	.LVL126:
 332:Src/uavcan.c  ****     offset += 2;
ARM GAS  /tmp/ccUNHGxP.s 			page 35


 333:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 64, &p->max);
 1258              		.loc 1 333 0
 1259 0088 05F11803 		add	r3, r5, #24
 1260 008c 4022     		movs	r2, #64
 1261 008e 9821     		movs	r1, #152
 1262 0090 2046     		mov	r0, r4
 1263 0092 FFF7FEFF 		bl	canardEncodeScalar
 1264              	.LVL127:
 334:Src/uavcan.c  ****     offset += 64;
 335:Src/uavcan.c  ****     
 336:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset, 6, &n);
 1265              		.loc 1 336 0
 1266 0096 0DF10703 		add	r3, sp, #7
 1267 009a 0622     		movs	r2, #6
 1268 009c D821     		movs	r1, #216
 1269 009e 2046     		mov	r0, r4
 1270 00a0 FFF7FEFF 		bl	canardEncodeScalar
 1271              	.LVL128:
 337:Src/uavcan.c  ****     offset += 6;
 338:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset,2,&tag);
 1272              		.loc 1 338 0
 1273 00a4 0DF10603 		add	r3, sp, #6
 1274 00a8 0222     		movs	r2, #2
 1275 00aa DE21     		movs	r1, #222
 1276 00ac 2046     		mov	r0, r4
 1277 00ae FFF7FEFF 		bl	canardEncodeScalar
 1278              	.LVL129:
 339:Src/uavcan.c  ****     offset += 2;
 340:Src/uavcan.c  ****     canardEncodeScalar(buffer, offset,64,&p->min);
 1279              		.loc 1 340 0
 1280 00b2 05F11003 		add	r3, r5, #16
 1281 00b6 4022     		movs	r2, #64
 1282 00b8 E021     		movs	r1, #224
 1283 00ba 2046     		mov	r0, r4
 1284 00bc FFF7FEFF 		bl	canardEncodeScalar
 1285              	.LVL130:
 341:Src/uavcan.c  ****     offset += 64;
 342:Src/uavcan.c  ****     
 343:Src/uavcan.c  ****     memcpy(&buffer[offset / 8], p->name, strlen((char const*)p->name));
 1286              		.loc 1 343 0
 1287 00c0 2434     		adds	r4, r4, #36
 1288              	.LVL131:
 1289 00c2 2E68     		ldr	r6, [r5]
 1290 00c4 3046     		mov	r0, r6
 1291 00c6 FFF7FEFF 		bl	strlen
 1292              	.LVL132:
 1293 00ca 0246     		mov	r2, r0
 1294 00cc 3146     		mov	r1, r6
 1295 00ce 2046     		mov	r0, r4
 1296 00d0 FFF7FEFF 		bl	memcpy
 1297              	.LVL133:
 344:Src/uavcan.c  ****     return  (offset/8 + strlen((char const*)p->name)); 
 1298              		.loc 1 344 0
 1299 00d4 2868     		ldr	r0, [r5]
 1300 00d6 FFF7FEFF 		bl	strlen
 1301              	.LVL134:
 1302 00da 2430     		adds	r0, r0, #36
ARM GAS  /tmp/ccUNHGxP.s 			page 36


 1303 00dc 80B2     		uxth	r0, r0
 1304              	.LVL135:
 1305              	.L96:
 345:Src/uavcan.c  **** }
 1306              		.loc 1 345 0
 1307 00de 02B0     		add	sp, sp, #8
 1308              	.LCFI34:
 1309              		.cfi_remember_state
 1310              		.cfi_def_cfa_offset 16
 1311              		@ sp needed
 1312 00e0 70BD     		pop	{r4, r5, r6, pc}
 1313              	.LVL136:
 1314              	.L98:
 1315              	.LCFI35:
 1316              		.cfi_restore_state
 297:Src/uavcan.c  ****         canardEncodeScalar(buffer, offset, 5, &n);
 1317              		.loc 1 297 0
 1318 00e2 0025     		movs	r5, #0
 1319 00e4 8DF80650 		strb	r5, [sp, #6]
 298:Src/uavcan.c  ****         offset += 5;
 1320              		.loc 1 298 0
 1321 00e8 0DF10703 		add	r3, sp, #7
 1322 00ec 0522     		movs	r2, #5
 1323 00ee 2946     		mov	r1, r5
 1324              	.LVL137:
 1325 00f0 2046     		mov	r0, r4
 1326              	.LVL138:
 1327 00f2 FFF7FEFF 		bl	canardEncodeScalar
 1328              	.LVL139:
 300:Src/uavcan.c  ****         offset += 3;
 1329              		.loc 1 300 0
 1330 00f6 0DF10603 		add	r3, sp, #6
 1331 00fa 0322     		movs	r2, #3
 1332 00fc 0521     		movs	r1, #5
 1333 00fe 2046     		mov	r0, r4
 1334 0100 FFF7FEFF 		bl	canardEncodeScalar
 1335              	.LVL140:
 303:Src/uavcan.c  ****         offset += 6;
 1336              		.loc 1 303 0
 1337 0104 0DF10703 		add	r3, sp, #7
 1338 0108 0622     		movs	r2, #6
 1339 010a 0821     		movs	r1, #8
 1340 010c 2046     		mov	r0, r4
 1341 010e FFF7FEFF 		bl	canardEncodeScalar
 1342              	.LVL141:
 305:Src/uavcan.c  ****         offset += 2;
 1343              		.loc 1 305 0
 1344 0112 0DF10603 		add	r3, sp, #6
 1345 0116 0222     		movs	r2, #2
 1346 0118 0E21     		movs	r1, #14
 1347 011a 2046     		mov	r0, r4
 1348 011c FFF7FEFF 		bl	canardEncodeScalar
 1349              	.LVL142:
 308:Src/uavcan.c  ****         offset += 6;
 1350              		.loc 1 308 0
 1351 0120 0DF10703 		add	r3, sp, #7
 1352 0124 0622     		movs	r2, #6
ARM GAS  /tmp/ccUNHGxP.s 			page 37


 1353 0126 1021     		movs	r1, #16
 1354 0128 2046     		mov	r0, r4
 1355 012a FFF7FEFF 		bl	canardEncodeScalar
 1356              	.LVL143:
 310:Src/uavcan.c  ****         offset += 2;
 1357              		.loc 1 310 0
 1358 012e 0DF10603 		add	r3, sp, #6
 1359 0132 0222     		movs	r2, #2
 1360 0134 1621     		movs	r1, #22
 1361 0136 2046     		mov	r0, r4
 1362 0138 FFF7FEFF 		bl	canardEncodeScalar
 1363              	.LVL144:
 312:Src/uavcan.c  ****         return ( offset / 8 + 1 );
 1364              		.loc 1 312 0
 1365 013c E570     		strb	r5, [r4, #3]
 313:Src/uavcan.c  ****     }
 1366              		.loc 1 313 0
 1367 013e 0420     		movs	r0, #4
 1368 0140 CDE7     		b	.L96
 1369              		.cfi_endproc
 1370              	.LFE80:
 1372              		.section	.text.getsetHandleCanard,"ax",%progbits
 1373              		.align	1
 1374              		.global	getsetHandleCanard
 1375              		.syntax unified
 1376              		.thumb
 1377              		.thumb_func
 1378              		.fpu softvfp
 1380              	getsetHandleCanard:
 1381              	.LFB81:
 346:Src/uavcan.c  **** 
 347:Src/uavcan.c  **** 
 348:Src/uavcan.c  **** void getsetHandleCanard(CanardRxTransfer* transfer)
 349:Src/uavcan.c  **** {
 1382              		.loc 1 349 0
 1383              		.cfi_startproc
 1384              		@ args = 0, pretend = 0, frame = 96
 1385              		@ frame_needed = 0, uses_anonymous_args = 0
 1386              	.LVL145:
 1387 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1388              	.LCFI36:
 1389              		.cfi_def_cfa_offset 20
 1390              		.cfi_offset 4, -20
 1391              		.cfi_offset 5, -16
 1392              		.cfi_offset 6, -12
 1393              		.cfi_offset 7, -8
 1394              		.cfi_offset 14, -4
 1395 0002 9FB0     		sub	sp, sp, #124
 1396              	.LCFI37:
 1397              		.cfi_def_cfa_offset 144
 1398 0004 0646     		mov	r6, r0
 350:Src/uavcan.c  ****     uint16_t index = 0xFFFF;
 1399              		.loc 1 350 0
 1400 0006 4FF6FF73 		movw	r3, #65535
 1401 000a ADF87630 		strh	r3, [sp, #118]	@ movhi
 351:Src/uavcan.c  ****     uint8_t tag    = 0;
 1402              		.loc 1 351 0
ARM GAS  /tmp/ccUNHGxP.s 			page 38


 1403 000e 0024     		movs	r4, #0
 1404 0010 8DF87540 		strb	r4, [sp, #117]
 1405              	.LVL146:
 352:Src/uavcan.c  ****     int offset     = 0;
 353:Src/uavcan.c  ****     int64_t val    = 0;
 1406              		.loc 1 353 0
 1407 0014 0022     		movs	r2, #0
 1408 0016 0023     		movs	r3, #0
 1409 0018 CDE91A23 		strd	r2, [sp, #104]
 354:Src/uavcan.c  **** 
 355:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset,  13, false, &index);
 1410              		.loc 1 355 0
 1411 001c 0DF17603 		add	r3, sp, #118
 1412 0020 0093     		str	r3, [sp]
 1413 0022 2346     		mov	r3, r4
 1414 0024 0D22     		movs	r2, #13
 1415 0026 2146     		mov	r1, r4
 1416 0028 FFF7FEFF 		bl	canardDecodeScalar
 1417              	.LVL147:
 356:Src/uavcan.c  ****     offset += 13;
 357:Src/uavcan.c  ****     canardDecodeScalar(transfer, offset, 3, false, &tag);
 1418              		.loc 1 357 0
 1419 002c 0DF17503 		add	r3, sp, #117
 1420 0030 0093     		str	r3, [sp]
 1421 0032 2346     		mov	r3, r4
 1422 0034 0322     		movs	r2, #3
 1423 0036 0D21     		movs	r1, #13
 1424 0038 3046     		mov	r0, r6
 1425 003a FFF7FEFF 		bl	canardDecodeScalar
 1426              	.LVL148:
 358:Src/uavcan.c  ****     offset += 3;
 359:Src/uavcan.c  **** 
 360:Src/uavcan.c  ****     if(tag == 1)
 1427              		.loc 1 360 0
 1428 003e 9DF87530 		ldrb	r3, [sp, #117]	@ zero_extendqisi2
 1429 0042 012B     		cmp	r3, #1
 1430 0044 0FD0     		beq	.L115
 358:Src/uavcan.c  ****     offset += 3;
 1431              		.loc 1 358 0
 1432 0046 1025     		movs	r5, #16
 1433              	.LVL149:
 1434              	.L100:
 361:Src/uavcan.c  ****     {
 362:Src/uavcan.c  ****         canardDecodeScalar(transfer, offset, 64, false, &val);
 363:Src/uavcan.c  ****         offset += 64;
 364:Src/uavcan.c  ****     } 
 365:Src/uavcan.c  **** 
 366:Src/uavcan.c  ****     uint16_t n = transfer->payload_len - offset / 8 ;
 1435              		.loc 1 366 0
 1436 0048 B78A     		ldrh	r7, [r6, #20]
 1437 004a 2B46     		mov	r3, r5
 1438 004c 002D     		cmp	r5, #0
 1439 004e 14DB     		blt	.L116
 1440              	.L101:
 1441 0050 DB10     		asrs	r3, r3, #3
 1442 0052 5B42     		negs	r3, r3
 1443 0054 9BB2     		uxth	r3, r3
ARM GAS  /tmp/ccUNHGxP.s 			page 39


 1444 0056 1F44     		add	r7, r7, r3
 1445 0058 BFB2     		uxth	r7, r7
 1446              	.LVL150:
 367:Src/uavcan.c  ****     uint8_t name[16]      = "";
 1447              		.loc 1 367 0
 1448 005a 0024     		movs	r4, #0
 1449 005c 1694     		str	r4, [sp, #88]
 1450 005e 1794     		str	r4, [sp, #92]
 1451 0060 1894     		str	r4, [sp, #96]
 1452 0062 1994     		str	r4, [sp, #100]
 1453              	.LVL151:
 1454              	.LBB22:
 368:Src/uavcan.c  ****     for(int i = 0; i < n; i++)
 1455              		.loc 1 368 0
 1456 0064 16E0     		b	.L102
 1457              	.LVL152:
 1458              	.L115:
 1459              	.LBE22:
 362:Src/uavcan.c  ****         offset += 64;
 1460              		.loc 1 362 0
 1461 0066 1AAB     		add	r3, sp, #104
 1462 0068 0093     		str	r3, [sp]
 1463 006a 2346     		mov	r3, r4
 1464 006c 4022     		movs	r2, #64
 1465 006e 1021     		movs	r1, #16
 1466 0070 3046     		mov	r0, r6
 1467 0072 FFF7FEFF 		bl	canardDecodeScalar
 1468              	.LVL153:
 363:Src/uavcan.c  ****     } 
 1469              		.loc 1 363 0
 1470 0076 5025     		movs	r5, #80
 1471 0078 E6E7     		b	.L100
 1472              	.LVL154:
 1473              	.L116:
 366:Src/uavcan.c  ****     uint8_t name[16]      = "";
 1474              		.loc 1 366 0
 1475 007a EB1D     		adds	r3, r5, #7
 1476              	.LVL155:
 1477 007c E8E7     		b	.L101
 1478              	.LVL156:
 1479              	.L103:
 1480              	.LBB23:
 369:Src/uavcan.c  ****     {
 370:Src/uavcan.c  ****         canardDecodeScalar(transfer, offset, 8, false, &name[i]);
 1481              		.loc 1 370 0 discriminator 3
 1482 007e 16AB     		add	r3, sp, #88
 1483 0080 2344     		add	r3, r3, r4
 1484 0082 0093     		str	r3, [sp]
 1485 0084 0023     		movs	r3, #0
 1486 0086 0822     		movs	r2, #8
 1487 0088 2946     		mov	r1, r5
 1488 008a 3046     		mov	r0, r6
 1489 008c FFF7FEFF 		bl	canardDecodeScalar
 1490              	.LVL157:
 371:Src/uavcan.c  ****         offset += 8;
 1491              		.loc 1 371 0 discriminator 3
 1492 0090 0835     		adds	r5, r5, #8
ARM GAS  /tmp/ccUNHGxP.s 			page 40


 1493              	.LVL158:
 368:Src/uavcan.c  ****     {
 1494              		.loc 1 368 0 discriminator 3
 1495 0092 0134     		adds	r4, r4, #1
 1496              	.LVL159:
 1497              	.L102:
 368:Src/uavcan.c  ****     {
 1498              		.loc 1 368 0 is_stmt 0 discriminator 1
 1499 0094 BC42     		cmp	r4, r7
 1500 0096 F2DB     		blt	.L103
 1501              	.LVL160:
 1502              	.LBE23:
 372:Src/uavcan.c  ****     }
 373:Src/uavcan.c  **** 
 374:Src/uavcan.c  ****     param_t * p = NULL;
 375:Src/uavcan.c  **** 
 376:Src/uavcan.c  ****     if(strlen((char const*)name))
 1503              		.loc 1 376 0 is_stmt 1
 1504 0098 9DF85830 		ldrb	r3, [sp, #88]	@ zero_extendqisi2
 1505 009c 13BB     		cbnz	r3, .L111
 377:Src/uavcan.c  ****     {
 378:Src/uavcan.c  ****         p = getParamByName(name);
 379:Src/uavcan.c  ****     }
 380:Src/uavcan.c  ****     else
 381:Src/uavcan.c  ****     {
 382:Src/uavcan.c  ****         p = getParamByIndex(index);
 1506              		.loc 1 382 0
 1507 009e BDF87630 		ldrh	r3, [sp, #118]
 1508              	.LVL161:
 1509              	.LBB24:
 1510              	.LBB25:
 270:Src/uavcan.c  ****   {
 1511              		.loc 1 270 0
 1512 00a2 022B     		cmp	r3, #2
 1513 00a4 44D8     		bhi	.L112
 275:Src/uavcan.c  **** }
 1514              		.loc 1 275 0
 1515 00a6 03EB8303 		add	r3, r3, r3, lsl #2
 1516              	.LVL162:
 1517 00aa DA00     		lsls	r2, r3, #3
 1518 00ac 264D     		ldr	r5, .L119+8
 1519              	.LVL163:
 1520 00ae 1544     		add	r5, r5, r2
 1521 00b0 1BE0     		b	.L107
 1522              	.LVL164:
 1523              	.L106:
 1524              	.LBE25:
 1525              	.LBE24:
 1526              	.LBB27:
 1527              	.LBB28:
 1528              	.LBB29:
 280:Src/uavcan.c  ****   {
 1529              		.loc 1 280 0
 1530 00b2 0134     		adds	r4, r4, #1
 1531              	.LVL165:
 1532 00b4 A4B2     		uxth	r4, r4
 1533              	.LVL166:
ARM GAS  /tmp/ccUNHGxP.s 			page 41


 1534              	.L104:
 1535 00b6 022C     		cmp	r4, #2
 1536 00b8 16D8     		bhi	.L117
 282:Src/uavcan.c  ****     {
 1537              		.loc 1 282 0
 1538 00ba 04EB8402 		add	r2, r4, r4, lsl #2
 1539 00be D300     		lsls	r3, r2, #3
 1540 00c0 214A     		ldr	r2, .L119+8
 1541 00c2 D558     		ldr	r5, [r2, r3]
 1542 00c4 2846     		mov	r0, r5
 1543 00c6 FFF7FEFF 		bl	strlen
 1544              	.LVL167:
 1545 00ca 0246     		mov	r2, r0
 1546 00cc 2946     		mov	r1, r5
 1547 00ce 16A8     		add	r0, sp, #88
 1548 00d0 FFF7FEFF 		bl	strncmp
 1549              	.LVL168:
 1550 00d4 0028     		cmp	r0, #0
 1551 00d6 ECD1     		bne	.L106
 284:Src/uavcan.c  ****     }
 1552              		.loc 1 284 0
 1553 00d8 04EB8407 		add	r7, r4, r4, lsl #2
 1554              	.LVL169:
 1555 00dc FB00     		lsls	r3, r7, #3
 1556 00de 1A4D     		ldr	r5, .L119+8
 1557 00e0 1D44     		add	r5, r5, r3
 1558 00e2 02E0     		b	.L107
 1559              	.LVL170:
 1560              	.L111:
 1561              	.LBE29:
 1562              	.LBE28:
 1563              	.LBE27:
 1564 00e4 0024     		movs	r4, #0
 1565              	.LVL171:
 1566 00e6 E6E7     		b	.L104
 1567              	.LVL172:
 1568              	.L117:
 1569              	.LBB31:
 1570              	.LBB30:
 287:Src/uavcan.c  **** }
 1571              		.loc 1 287 0
 1572 00e8 0025     		movs	r5, #0
 1573              	.LVL173:
 1574              	.L107:
 1575              	.LBE30:
 1576              	.LBE31:
 383:Src/uavcan.c  ****     }
 384:Src/uavcan.c  **** 
 385:Src/uavcan.c  ****     if((p)&&(tag == 1))
 1577              		.loc 1 385 0
 1578 00ea 1DB1     		cbz	r5, .L109
 1579              		.loc 1 385 0 is_stmt 0 discriminator 1
 1580 00ec 9DF87530 		ldrb	r3, [sp, #117]	@ zero_extendqisi2
 1581 00f0 012B     		cmp	r3, #1
 1582 00f2 1FD0     		beq	.L118
 1583              	.L109:
 386:Src/uavcan.c  ****     {
ARM GAS  /tmp/ccUNHGxP.s 			page 42


 387:Src/uavcan.c  ****         p->val = val;
 388:Src/uavcan.c  ****     }
 389:Src/uavcan.c  **** 
 390:Src/uavcan.c  ****     uint8_t  buffer[64] = "";
 1584              		.loc 1 390 0 is_stmt 1
 1585 00f4 0024     		movs	r4, #0
 1586 00f6 0694     		str	r4, [sp, #24]
 1587 00f8 3C22     		movs	r2, #60
 1588 00fa 2146     		mov	r1, r4
 1589 00fc 07A8     		add	r0, sp, #28
 1590 00fe FFF7FEFF 		bl	memset
 1591              	.LVL174:
 391:Src/uavcan.c  ****     uint16_t len = encodeParamCanard(p, buffer);
 1592              		.loc 1 391 0
 1593 0102 06AF     		add	r7, sp, #24
 1594 0104 3946     		mov	r1, r7
 1595 0106 2846     		mov	r0, r5
 1596 0108 FFF7FEFF 		bl	encodeParamCanard
 1597              	.LVL175:
 392:Src/uavcan.c  ****     int result = canardRequestOrRespond(&g_canard,
 1598              		.loc 1 392 0
 1599 010c F17E     		ldrb	r1, [r6, #27]	@ zero_extendqisi2
 1600 010e 0590     		str	r0, [sp, #20]
 1601 0110 0497     		str	r7, [sp, #16]
 1602 0112 0394     		str	r4, [sp, #12]
 1603 0114 B37E     		ldrb	r3, [r6, #26]	@ zero_extendqisi2
 1604 0116 0293     		str	r3, [sp, #8]
 1605 0118 1936     		adds	r6, r6, #25
 1606              	.LVL176:
 1607 011a 0196     		str	r6, [sp, #4]
 1608 011c 0B23     		movs	r3, #11
 1609 011e 0093     		str	r3, [sp]
 1610 0120 07A3     		adr	r3, .L119
 1611 0122 D3E90023 		ldrd	r2, [r3]
 1612 0126 0948     		ldr	r0, .L119+12
 1613              	.LVL177:
 1614 0128 FFF7FEFF 		bl	canardRequestOrRespond
 1615              	.LVL178:
 393:Src/uavcan.c  ****                                         transfer->source_node_id,
 394:Src/uavcan.c  ****                                         UAVCAN_PROTOCOL_PARAM_GETSET_SIGNATURE,
 395:Src/uavcan.c  ****                                         UAVCAN_PROTOCOL_PARAM_GETSET_ID,
 396:Src/uavcan.c  ****                                         &transfer->transfer_id,
 397:Src/uavcan.c  ****                                         transfer->priority,
 398:Src/uavcan.c  ****                                         CanardResponse,
 399:Src/uavcan.c  ****                                         &buffer[0],
 400:Src/uavcan.c  ****                                         (uint16_t)len);
 401:Src/uavcan.c  ****   
 402:Src/uavcan.c  **** }...
 1616              		.loc 1 402 0
 1617 012c 1FB0     		add	sp, sp, #124
 1618              	.LCFI38:
 1619              		.cfi_remember_state
 1620              		.cfi_def_cfa_offset 20
 1621              		@ sp needed
 1622 012e F0BD     		pop	{r4, r5, r6, r7, pc}
 1623              	.LVL179:
 1624              	.L112:
ARM GAS  /tmp/ccUNHGxP.s 			page 43


 1625              	.LCFI39:
 1626              		.cfi_restore_state
 1627              	.LBB32:
 1628              	.LBB26:
 272:Src/uavcan.c  ****     return NULL;
 1629              		.loc 1 272 0
 1630 0130 0025     		movs	r5, #0
 1631              	.LVL180:
 1632 0132 DAE7     		b	.L107
 1633              	.LVL181:
 1634              	.L118:
 1635              	.LBE26:
 1636              	.LBE32:
 387:Src/uavcan.c  ****         p->val = val;
 1637              		.loc 1 387 0
 1638 0134 DDE91A23 		ldrd	r2, [sp, #104]
 1639 0138 C5E90223 		strd	r2, [r5, #8]
 1640 013c DAE7     		b	.L109
 1641              	.L120:
 1642 013e 00BF     		.align	3
 1643              	.L119:
 1644 0140 D5A4D139 		.word	970040533
 1645 0144 F922B6A7 		.word	-1481235719
 1646 0148 00000000 		.word	.LANCHOR10
 1647 014c 00000000 		.word	.LANCHOR2
 1648              		.cfi_endproc
 1649              	.LFE81:
 1651              		.section	.text.onTransferReceived,"ax",%progbits
 1652              		.align	1
 1653              		.global	onTransferReceived
 1654              		.syntax unified
 1655              		.thumb
 1656              		.thumb_func
 1657              		.fpu softvfp
 1659              	onTransferReceived:
 1660              	.LFB66:
  50:Src/uavcan.c  **** {
 1661              		.loc 1 50 0
 1662              		.cfi_startproc
 1663              		@ args = 0, pretend = 0, frame = 0
 1664              		@ frame_needed = 0, uses_anonymous_args = 0
 1665              	.LVL182:
 1666 0000 10B5     		push	{r4, lr}
 1667              	.LCFI40:
 1668              		.cfi_def_cfa_offset 8
 1669              		.cfi_offset 4, -8
 1670              		.cfi_offset 14, -4
 1671 0002 0C46     		mov	r4, r1
  51:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) && (transfer->data_type_id == UAVCAN
 1672              		.loc 1 51 0
 1673 0004 0B7E     		ldrb	r3, [r1, #24]	@ zero_extendqisi2
 1674 0006 012B     		cmp	r3, #1
 1675 0008 08D0     		beq	.L126
 1676              	.LVL183:
 1677              	.L122:
  56:Src/uavcan.c  ****     if (transfer->data_type_id == UAVCAN_EQUIPMENT_ESC_RAWCOMMAND_ID)
 1678              		.loc 1 56 0
ARM GAS  /tmp/ccUNHGxP.s 			page 44


 1679 000a E28A     		ldrh	r2, [r4, #22]
 1680 000c 40F20643 		movw	r3, #1030
 1681 0010 9A42     		cmp	r2, r3
 1682 0012 0AD0     		beq	.L127
 1683              	.L123:
  61:Src/uavcan.c  ****     if (transfer->data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID)
 1684              		.loc 1 61 0
 1685 0014 E38A     		ldrh	r3, [r4, #22]
 1686 0016 0B2B     		cmp	r3, #11
 1687 0018 0BD0     		beq	.L128
 1688              	.L121:
 1689 001a 10BD     		pop	{r4, pc}
 1690              	.LVL184:
 1691              	.L126:
  51:Src/uavcan.c  ****     if ((transfer->transfer_type == CanardTransferTypeRequest) && (transfer->data_type_id == UAVCAN
 1692              		.loc 1 51 0 discriminator 1
 1693 001c CB8A     		ldrh	r3, [r1, #22]
 1694 001e 012B     		cmp	r3, #1
 1695 0020 F3D1     		bne	.L122
  53:Src/uavcan.c  ****         getNodeInfoHandleCanard(transfer);
 1696              		.loc 1 53 0
 1697 0022 0846     		mov	r0, r1
 1698              	.LVL185:
 1699 0024 FFF7FEFF 		bl	getNodeInfoHandleCanard
 1700              	.LVL186:
 1701 0028 EFE7     		b	.L122
 1702              	.L127:
  58:Src/uavcan.c  ****         rawcmdHandleCanard(transfer);
 1703              		.loc 1 58 0
 1704 002a 2046     		mov	r0, r4
 1705 002c FFF7FEFF 		bl	rawcmdHandleCanard
 1706              	.LVL187:
 1707 0030 F0E7     		b	.L123
 1708              	.L128:
  63:Src/uavcan.c  ****         getsetHandleCanard(transfer);
 1709              		.loc 1 63 0
 1710 0032 2046     		mov	r0, r4
 1711 0034 FFF7FEFF 		bl	getsetHandleCanard
 1712              	.LVL188:
  66:Src/uavcan.c  **** }
 1713              		.loc 1 66 0
 1714 0038 EFE7     		b	.L121
 1715              		.cfi_endproc
 1716              	.LFE66:
 1718              		.global	parameters
 1719              		.global	rc_pwm
 1720              		.section	.bss.g_canard,"aw",%nobits
 1721              		.align	2
 1722              		.set	.LANCHOR2,. + 0
 1725              	g_canard:
 1726 0000 00000000 		.space	36
 1726      00000000 
 1726      00000000 
 1726      00000000 
 1726      00000000 
 1727              		.section	.bss.g_canard_memory_pool,"aw",%nobits
 1728              		.align	2
ARM GAS  /tmp/ccUNHGxP.s 			page 45


 1729              		.set	.LANCHOR1,. + 0
 1732              	g_canard_memory_pool:
 1733 0000 00000000 		.space	1024
 1733      00000000 
 1733      00000000 
 1733      00000000 
 1733      00000000 
 1734              		.section	.bss.publish_time.7905,"aw",%nobits
 1735              		.align	2
 1736              		.set	.LANCHOR3,. + 0
 1739              	publish_time.7905:
 1740 0000 00000000 		.space	4
 1741              		.section	.bss.rc_pwm,"aw",%nobits
 1742              		.align	2
 1743              		.set	.LANCHOR9,. + 0
 1746              	rc_pwm:
 1747 0000 00000000 		.space	12
 1747      00000000 
 1747      00000000 
 1748              		.section	.bss.spin_time.7897,"aw",%nobits
 1749              		.align	2
 1750              		.set	.LANCHOR7,. + 0
 1753              	spin_time.7897:
 1754 0000 00000000 		.space	4
 1755              		.section	.bss.step.7906,"aw",%nobits
 1756              		.align	2
 1757              		.set	.LANCHOR4,. + 0
 1760              	step.7906:
 1761 0000 00000000 		.space	4
 1762              		.section	.bss.transfer_id.7899,"aw",%nobits
 1763              		.set	.LANCHOR8,. + 0
 1766              	transfer_id.7899:
 1767 0000 00       		.space	1
 1768              		.section	.bss.transfer_id.7909,"aw",%nobits
 1769              		.set	.LANCHOR6,. + 0
 1772              	transfer_id.7909:
 1773 0000 00       		.space	1
 1774              		.section	.data.parameters,"aw",%progbits
 1775              		.align	3
 1776              		.set	.LANCHOR10,. + 0
 1779              	parameters:
 1780 0000 00000000 		.word	.LC7
 1781 0004 00000000 		.space	4
 1782 0008 00000000 		.word	0
 1783 000c 00000000 		.word	0
 1784 0010 0A000000 		.word	10
 1785 0014 00000000 		.word	0
 1786 0018 14000000 		.word	20
 1787 001c 00000000 		.word	0
 1788 0020 0F000000 		.word	15
 1789 0024 00000000 		.word	0
 1790 0028 08000000 		.word	.LC8
 1791 002c 00000000 		.space	4
 1792 0030 01000000 		.word	1
 1793 0034 00000000 		.word	0
 1794 0038 00000000 		.word	0
 1795 003c 00000000 		.word	0
ARM GAS  /tmp/ccUNHGxP.s 			page 46


 1796 0040 64000000 		.word	100
 1797 0044 00000000 		.word	0
 1798 0048 19000000 		.word	25
 1799 004c 00000000 		.word	0
 1800 0050 10000000 		.word	.LC9
 1801 0054 00000000 		.space	4
 1802 0058 02000000 		.word	2
 1803 005c 00000000 		.word	0
 1804 0060 02000000 		.word	2
 1805 0064 00000000 		.word	0
 1806 0068 08000000 		.word	8
 1807 006c 00000000 		.word	0
 1808 0070 03000000 		.word	3
 1809 0074 00000000 		.word	0
 1810              		.section	.rodata.__func__.5923,"a",%progbits
 1811              		.align	2
 1812              		.set	.LANCHOR0,. + 0
 1815              	__func__.5923:
 1816 0000 63616E61 		.ascii	"canardSTM32ComputeCANTimings\000"
 1816      72645354 
 1816      4D333243 
 1816      6F6D7075 
 1816      74654341 
 1817              		.section	.rodata.makeNodeInfoMessage.str1.4,"aMS",%progbits,1
 1818              		.align	2
 1819              	.LC5:
 1820 0000 736B7979 		.ascii	"skyyu.node.demo\000"
 1820      752E6E6F 
 1820      64652E64 
 1820      656D6F00 
 1821              		.section	.rodata.publishCanard.str1.4,"aMS",%progbits,1
 1822              		.align	2
 1823              	.LC3:
 1824 0000 73696E00 		.ascii	"sin\000"
 1825              	.LC4:
 1826 0004 73747000 		.ascii	"stp\000"
 1827              		.section	.rodata.showRcpwmonUart.str1.4,"aMS",%progbits,1
 1828              		.align	2
 1829              	.LC6:
 1830 0000 0A00     		.ascii	"\012\000"
 1831              		.section	.rodata.sine_wave,"a",%progbits
 1832              		.align	2
 1833              		.set	.LANCHOR5,. + 0
 1836              	sine_wave:
 1837 0000 80       		.byte	-128
 1838 0001 83       		.byte	-125
 1839 0002 86       		.byte	-122
 1840 0003 89       		.byte	-119
 1841 0004 8C       		.byte	-116
 1842 0005 90       		.byte	-112
 1843 0006 93       		.byte	-109
 1844 0007 96       		.byte	-106
 1845 0008 99       		.byte	-103
 1846 0009 9C       		.byte	-100
 1847 000a 9F       		.byte	-97
 1848 000b A2       		.byte	-94
 1849 000c A5       		.byte	-91
ARM GAS  /tmp/ccUNHGxP.s 			page 47


 1850 000d A8       		.byte	-88
 1851 000e AB       		.byte	-85
 1852 000f AE       		.byte	-82
 1853 0010 B1       		.byte	-79
 1854 0011 B3       		.byte	-77
 1855 0012 B6       		.byte	-74
 1856 0013 B9       		.byte	-71
 1857 0014 BC       		.byte	-68
 1858 0015 BF       		.byte	-65
 1859 0016 C1       		.byte	-63
 1860 0017 C4       		.byte	-60
 1861 0018 C7       		.byte	-57
 1862 0019 C9       		.byte	-55
 1863 001a CC       		.byte	-52
 1864 001b CE       		.byte	-50
 1865 001c D1       		.byte	-47
 1866 001d D3       		.byte	-45
 1867 001e D5       		.byte	-43
 1868 001f D8       		.byte	-40
 1869 0020 DA       		.byte	-38
 1870 0021 DC       		.byte	-36
 1871 0022 DE       		.byte	-34
 1872 0023 E0       		.byte	-32
 1873 0024 E2       		.byte	-30
 1874 0025 E4       		.byte	-28
 1875 0026 E6       		.byte	-26
 1876 0027 E8       		.byte	-24
 1877 0028 EA       		.byte	-22
 1878 0029 EB       		.byte	-21
 1879 002a ED       		.byte	-19
 1880 002b EF       		.byte	-17
 1881 002c F0       		.byte	-16
 1882 002d F1       		.byte	-15
 1883 002e F3       		.byte	-13
 1884 002f F4       		.byte	-12
 1885 0030 F5       		.byte	-11
 1886 0031 F6       		.byte	-10
 1887 0032 F8       		.byte	-8
 1888 0033 F9       		.byte	-7
 1889 0034 FA       		.byte	-6
 1890 0035 FA       		.byte	-6
 1891 0036 FB       		.byte	-5
 1892 0037 FC       		.byte	-4
 1893 0038 FD       		.byte	-3
 1894 0039 FD       		.byte	-3
 1895 003a FE       		.byte	-2
 1896 003b FE       		.byte	-2
 1897 003c FE       		.byte	-2
 1898 003d FF       		.byte	-1
 1899 003e FF       		.byte	-1
 1900 003f FF       		.byte	-1
 1901 0040 FF       		.byte	-1
 1902 0041 FF       		.byte	-1
 1903 0042 FF       		.byte	-1
 1904 0043 FF       		.byte	-1
 1905 0044 FE       		.byte	-2
 1906 0045 FE       		.byte	-2
ARM GAS  /tmp/ccUNHGxP.s 			page 48


 1907 0046 FE       		.byte	-2
 1908 0047 FD       		.byte	-3
 1909 0048 FD       		.byte	-3
 1910 0049 FC       		.byte	-4
 1911 004a FB       		.byte	-5
 1912 004b FA       		.byte	-6
 1913 004c FA       		.byte	-6
 1914 004d F9       		.byte	-7
 1915 004e F8       		.byte	-8
 1916 004f F6       		.byte	-10
 1917 0050 F5       		.byte	-11
 1918 0051 F4       		.byte	-12
 1919 0052 F3       		.byte	-13
 1920 0053 F1       		.byte	-15
 1921 0054 F0       		.byte	-16
 1922 0055 EF       		.byte	-17
 1923 0056 ED       		.byte	-19
 1924 0057 EB       		.byte	-21
 1925 0058 EA       		.byte	-22
 1926 0059 E8       		.byte	-24
 1927 005a E6       		.byte	-26
 1928 005b E4       		.byte	-28
 1929 005c E2       		.byte	-30
 1930 005d E0       		.byte	-32
 1931 005e DE       		.byte	-34
 1932 005f DC       		.byte	-36
 1933 0060 DA       		.byte	-38
 1934 0061 D8       		.byte	-40
 1935 0062 D5       		.byte	-43
 1936 0063 D3       		.byte	-45
 1937 0064 D1       		.byte	-47
 1938 0065 CE       		.byte	-50
 1939 0066 CC       		.byte	-52
 1940 0067 C9       		.byte	-55
 1941 0068 C7       		.byte	-57
 1942 0069 C4       		.byte	-60
 1943 006a C1       		.byte	-63
 1944 006b BF       		.byte	-65
 1945 006c BC       		.byte	-68
 1946 006d B9       		.byte	-71
 1947 006e B6       		.byte	-74
 1948 006f B3       		.byte	-77
 1949 0070 B1       		.byte	-79
 1950 0071 AE       		.byte	-82
 1951 0072 AB       		.byte	-85
 1952 0073 A8       		.byte	-88
 1953 0074 A5       		.byte	-91
 1954 0075 A2       		.byte	-94
 1955 0076 9F       		.byte	-97
 1956 0077 9C       		.byte	-100
 1957 0078 99       		.byte	-103
 1958 0079 96       		.byte	-106
 1959 007a 93       		.byte	-109
 1960 007b 90       		.byte	-112
 1961 007c 8C       		.byte	-116
 1962 007d 89       		.byte	-119
 1963 007e 86       		.byte	-122
ARM GAS  /tmp/ccUNHGxP.s 			page 49


 1964 007f 83       		.byte	-125
 1965 0080 80       		.byte	-128
 1966 0081 7D       		.byte	125
 1967 0082 7A       		.byte	122
 1968 0083 77       		.byte	119
 1969 0084 74       		.byte	116
 1970 0085 70       		.byte	112
 1971 0086 6D       		.byte	109
 1972 0087 6A       		.byte	106
 1973 0088 67       		.byte	103
 1974 0089 64       		.byte	100
 1975 008a 61       		.byte	97
 1976 008b 5E       		.byte	94
 1977 008c 5B       		.byte	91
 1978 008d 58       		.byte	88
 1979 008e 55       		.byte	85
 1980 008f 52       		.byte	82
 1981 0090 4F       		.byte	79
 1982 0091 4D       		.byte	77
 1983 0092 4A       		.byte	74
 1984 0093 47       		.byte	71
 1985 0094 44       		.byte	68
 1986 0095 41       		.byte	65
 1987 0096 3F       		.byte	63
 1988 0097 3C       		.byte	60
 1989 0098 39       		.byte	57
 1990 0099 37       		.byte	55
 1991 009a 34       		.byte	52
 1992 009b 32       		.byte	50
 1993 009c 2F       		.byte	47
 1994 009d 2D       		.byte	45
 1995 009e 2B       		.byte	43
 1996 009f 28       		.byte	40
 1997 00a0 26       		.byte	38
 1998 00a1 24       		.byte	36
 1999 00a2 22       		.byte	34
 2000 00a3 20       		.byte	32
 2001 00a4 1E       		.byte	30
 2002 00a5 1C       		.byte	28
 2003 00a6 1A       		.byte	26
 2004 00a7 18       		.byte	24
 2005 00a8 16       		.byte	22
 2006 00a9 15       		.byte	21
 2007 00aa 13       		.byte	19
 2008 00ab 11       		.byte	17
 2009 00ac 10       		.byte	16
 2010 00ad 0F       		.byte	15
 2011 00ae 0D       		.byte	13
 2012 00af 0C       		.byte	12
 2013 00b0 0B       		.byte	11
 2014 00b1 0A       		.byte	10
 2015 00b2 08       		.byte	8
 2016 00b3 07       		.byte	7
 2017 00b4 06       		.byte	6
 2018 00b5 06       		.byte	6
 2019 00b6 05       		.byte	5
 2020 00b7 04       		.byte	4
ARM GAS  /tmp/ccUNHGxP.s 			page 50


 2021 00b8 03       		.byte	3
 2022 00b9 03       		.byte	3
 2023 00ba 02       		.byte	2
 2024 00bb 02       		.byte	2
 2025 00bc 02       		.byte	2
 2026 00bd 01       		.byte	1
 2027 00be 01       		.byte	1
 2028 00bf 01       		.byte	1
 2029 00c0 01       		.byte	1
 2030 00c1 01       		.byte	1
 2031 00c2 01       		.byte	1
 2032 00c3 01       		.byte	1
 2033 00c4 02       		.byte	2
 2034 00c5 02       		.byte	2
 2035 00c6 02       		.byte	2
 2036 00c7 03       		.byte	3
 2037 00c8 03       		.byte	3
 2038 00c9 04       		.byte	4
 2039 00ca 05       		.byte	5
 2040 00cb 06       		.byte	6
 2041 00cc 06       		.byte	6
 2042 00cd 07       		.byte	7
 2043 00ce 08       		.byte	8
 2044 00cf 0A       		.byte	10
 2045 00d0 0B       		.byte	11
 2046 00d1 0C       		.byte	12
 2047 00d2 0D       		.byte	13
 2048 00d3 0F       		.byte	15
 2049 00d4 10       		.byte	16
 2050 00d5 11       		.byte	17
 2051 00d6 13       		.byte	19
 2052 00d7 15       		.byte	21
 2053 00d8 16       		.byte	22
 2054 00d9 18       		.byte	24
 2055 00da 1A       		.byte	26
 2056 00db 1C       		.byte	28
 2057 00dc 1E       		.byte	30
 2058 00dd 20       		.byte	32
 2059 00de 22       		.byte	34
 2060 00df 24       		.byte	36
 2061 00e0 26       		.byte	38
 2062 00e1 28       		.byte	40
 2063 00e2 2B       		.byte	43
 2064 00e3 2D       		.byte	45
 2065 00e4 2F       		.byte	47
 2066 00e5 32       		.byte	50
 2067 00e6 34       		.byte	52
 2068 00e7 37       		.byte	55
 2069 00e8 39       		.byte	57
 2070 00e9 3C       		.byte	60
 2071 00ea 3F       		.byte	63
 2072 00eb 41       		.byte	65
 2073 00ec 44       		.byte	68
 2074 00ed 47       		.byte	71
 2075 00ee 4A       		.byte	74
 2076 00ef 4D       		.byte	77
 2077 00f0 4F       		.byte	79
ARM GAS  /tmp/ccUNHGxP.s 			page 51


 2078 00f1 52       		.byte	82
 2079 00f2 55       		.byte	85
 2080 00f3 58       		.byte	88
 2081 00f4 5B       		.byte	91
 2082 00f5 5E       		.byte	94
 2083 00f6 61       		.byte	97
 2084 00f7 64       		.byte	100
 2085 00f8 67       		.byte	103
 2086 00f9 6A       		.byte	106
 2087 00fa 6D       		.byte	109
 2088 00fb 70       		.byte	112
 2089 00fc 74       		.byte	116
 2090 00fd 77       		.byte	119
 2091 00fe 7A       		.byte	122
 2092 00ff 7D       		.byte	125
 2093              		.section	.rodata.str1.4,"aMS",%progbits,1
 2094              		.align	2
 2095              	.LC7:
 2096 0000 70617261 		.ascii	"param0\000"
 2096      6D3000
 2097 0007 00       		.space	1
 2098              	.LC8:
 2099 0008 70617261 		.ascii	"param1\000"
 2099      6D3100
 2100 000f 00       		.space	1
 2101              	.LC9:
 2102 0010 70617261 		.ascii	"param2\000"
 2102      6D3200
 2103              		.section	.rodata.uavcanInit.str1.4,"aMS",%progbits,1
 2104              		.align	2
 2105              	.LC0:
 2106 0000 6273315F 		.ascii	"bs1_bs2_sum > bs1\000"
 2106      6273325F 
 2106      73756D20 
 2106      3E206273 
 2106      3100
 2107 0012 0000     		.space	2
 2108              	.LC1:
 2109 0014 6C696263 		.ascii	"libcanard/drivers/stm32/canard_stm32.h\000"
 2109      616E6172 
 2109      642F6472 
 2109      69766572 
 2109      732F7374 
 2110 003b 00       		.space	1
 2111              	.LC2:
 2112 003c 3000     		.ascii	"0\000"
 2113              		.text
 2114              	.Letext0:
 2115              		.file 3 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/machine/_default_types.
 2116              		.file 4 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 2117              		.file 5 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 2118              		.file 6 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 2119              		.file 7 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 2120              		.file 8 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_stdint.h"
 2121              		.file 9 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/stdlib.h"
 2122              		.file 10 "libcanard/canard.h"
 2123              		.file 11 "Drivers/CMSIS/Include/core_cm3.h"
ARM GAS  /tmp/ccUNHGxP.s 			page 52


 2124              		.file 12 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 2125              		.file 13 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 2126              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 2127              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 2128              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 2129              		.file 17 "Inc/uavcan.h"
 2130              		.file 18 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/string.h"
 2131              		.file 19 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 2132              		.file 20 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 2133              		.file 21 "/usr/bin/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/assert.h"
 2134              		.file 22 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_rcc.h"
ARM GAS  /tmp/ccUNHGxP.s 			page 53


DEFINED SYMBOLS
                            *ABS*:0000000000000000 uavcan.c
     /tmp/ccUNHGxP.s:16     .text.shouldAcceptTransfer:0000000000000000 $t
     /tmp/ccUNHGxP.s:23     .text.shouldAcceptTransfer:0000000000000000 shouldAcceptTransfer
     /tmp/ccUNHGxP.s:88     .text.shouldAcceptTransfer:0000000000000048 $d
     /tmp/ccUNHGxP.s:98     .text.uavcanInit:0000000000000000 $t
     /tmp/ccUNHGxP.s:105    .text.uavcanInit:0000000000000000 uavcanInit
     /tmp/ccUNHGxP.s:362    .text.uavcanInit:000000000000011c $d
     /tmp/ccUNHGxP.s:1659   .text.onTransferReceived:0000000000000000 onTransferReceived
     /tmp/ccUNHGxP.s:379    .text.sendCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:386    .text.sendCanard:0000000000000000 sendCanard
     /tmp/ccUNHGxP.s:449    .text.sendCanard:000000000000002c $d
     /tmp/ccUNHGxP.s:454    .text.receiveCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:461    .text.receiveCanard:0000000000000000 receiveCanard
     /tmp/ccUNHGxP.s:508    .text.receiveCanard:000000000000002c $d
     /tmp/ccUNHGxP.s:515    .text.publishCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:522    .text.publishCanard:0000000000000000 publishCanard
     /tmp/ccUNHGxP.s:666    .text.publishCanard:00000000000000f0 $d
     /tmp/ccUNHGxP.s:679    .text.makeNodeStatusMessage:0000000000000000 $t
     /tmp/ccUNHGxP.s:686    .text.makeNodeStatusMessage:0000000000000000 makeNodeStatusMessage
     /tmp/ccUNHGxP.s:749    .text.makeNodeStatusMessage:0000000000000054 $d
     /tmp/ccUNHGxP.s:754    .text.spinCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:761    .text.spinCanard:0000000000000000 spinCanard
     /tmp/ccUNHGxP.s:828    .text.spinCanard:0000000000000058 $d
     /tmp/ccUNHGxP.s:838    .text.readUniqueID:0000000000000000 $t
     /tmp/ccUNHGxP.s:845    .text.readUniqueID:0000000000000000 readUniqueID
     /tmp/ccUNHGxP.s:877    .text.makeNodeInfoMessage:0000000000000000 $t
     /tmp/ccUNHGxP.s:884    .text.makeNodeInfoMessage:0000000000000000 makeNodeInfoMessage
     /tmp/ccUNHGxP.s:953    .text.makeNodeInfoMessage:000000000000005c $d
     /tmp/ccUNHGxP.s:959    .text.getNodeInfoHandleCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:966    .text.getNodeInfoHandleCanard:0000000000000000 getNodeInfoHandleCanard
     /tmp/ccUNHGxP.s:1024   .text.getNodeInfoHandleCanard:0000000000000040 $d
     /tmp/ccUNHGxP.s:1031   .text.rawcmdHandleCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:1038   .text.rawcmdHandleCanard:0000000000000000 rawcmdHandleCanard
     /tmp/ccUNHGxP.s:1100   .text.rawcmdHandleCanard:0000000000000030 $d
     /tmp/ccUNHGxP.s:1105   .text.showRcpwmonUart:0000000000000000 $t
     /tmp/ccUNHGxP.s:1112   .text.showRcpwmonUart:0000000000000000 showRcpwmonUart
     /tmp/ccUNHGxP.s:1157   .text.showRcpwmonUart:0000000000000034 $d
     /tmp/ccUNHGxP.s:1164   .text.encodeParamCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:1171   .text.encodeParamCanard:0000000000000000 encodeParamCanard
     /tmp/ccUNHGxP.s:1373   .text.getsetHandleCanard:0000000000000000 $t
     /tmp/ccUNHGxP.s:1380   .text.getsetHandleCanard:0000000000000000 getsetHandleCanard
     /tmp/ccUNHGxP.s:1644   .text.getsetHandleCanard:0000000000000140 $d
     /tmp/ccUNHGxP.s:1652   .text.onTransferReceived:0000000000000000 $t
     /tmp/ccUNHGxP.s:1779   .data.parameters:0000000000000000 parameters
     /tmp/ccUNHGxP.s:1746   .bss.rc_pwm:0000000000000000 rc_pwm
     /tmp/ccUNHGxP.s:1721   .bss.g_canard:0000000000000000 $d
     /tmp/ccUNHGxP.s:1725   .bss.g_canard:0000000000000000 g_canard
     /tmp/ccUNHGxP.s:1728   .bss.g_canard_memory_pool:0000000000000000 $d
     /tmp/ccUNHGxP.s:1732   .bss.g_canard_memory_pool:0000000000000000 g_canard_memory_pool
     /tmp/ccUNHGxP.s:1735   .bss.publish_time.7905:0000000000000000 $d
     /tmp/ccUNHGxP.s:1739   .bss.publish_time.7905:0000000000000000 publish_time.7905
     /tmp/ccUNHGxP.s:1742   .bss.rc_pwm:0000000000000000 $d
     /tmp/ccUNHGxP.s:1749   .bss.spin_time.7897:0000000000000000 $d
     /tmp/ccUNHGxP.s:1753   .bss.spin_time.7897:0000000000000000 spin_time.7897
     /tmp/ccUNHGxP.s:1756   .bss.step.7906:0000000000000000 $d
     /tmp/ccUNHGxP.s:1760   .bss.step.7906:0000000000000000 step.7906
ARM GAS  /tmp/ccUNHGxP.s 			page 54


     /tmp/ccUNHGxP.s:1766   .bss.transfer_id.7899:0000000000000000 transfer_id.7899
     /tmp/ccUNHGxP.s:1767   .bss.transfer_id.7899:0000000000000000 $d
     /tmp/ccUNHGxP.s:1772   .bss.transfer_id.7909:0000000000000000 transfer_id.7909
     /tmp/ccUNHGxP.s:1773   .bss.transfer_id.7909:0000000000000000 $d
     /tmp/ccUNHGxP.s:1775   .data.parameters:0000000000000000 $d
     /tmp/ccUNHGxP.s:1811   .rodata.__func__.5923:0000000000000000 $d
     /tmp/ccUNHGxP.s:1815   .rodata.__func__.5923:0000000000000000 __func__.5923
     /tmp/ccUNHGxP.s:1818   .rodata.makeNodeInfoMessage.str1.4:0000000000000000 $d
     /tmp/ccUNHGxP.s:1822   .rodata.publishCanard.str1.4:0000000000000000 $d
     /tmp/ccUNHGxP.s:1828   .rodata.showRcpwmonUart.str1.4:0000000000000000 $d
     /tmp/ccUNHGxP.s:1832   .rodata.sine_wave:0000000000000000 $d
     /tmp/ccUNHGxP.s:1836   .rodata.sine_wave:0000000000000000 sine_wave
     /tmp/ccUNHGxP.s:2094   .rodata.str1.4:0000000000000000 $d
     /tmp/ccUNHGxP.s:2104   .rodata.uavcanInit.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_RCC_GetPCLK1Freq
__assert_func
canardSTM32Init
canardInit
canardSetLocalNodeID
canardPeekTxQueue
canardSTM32Transmit
canardPopTxQueue
canardSTM32Receive
HAL_GetTick
canardHandleRxFrame
__aeabi_ui2f
__aeabi_i2f
memset
canardEncodeScalar
canardBroadcast
HAL_GPIO_TogglePin
canardRequestOrRespond
canardDecodeScalar
itoa
HAL_UART_Transmit
huart1
strlen
memcpy
strncmp
